**Принцип единой ответственности** (*Single Responsibility Principle*): у каждой функции, класса или модуля должна быть одна чёткая задача.
**DRY** (*Don't Repeat Yourself*): избегайте дублирования логики.
**KISS** (*Keep It Simple, Stupid*): решения должны быть как можно проще.
**YAGNI** (*You Aren't Gonna Need It*): не реализуйте функциональность заранее, если она не требуется сейчас.
**Fail fast**: ошибки должны проявляться как можно раньше.
**Principle of least privilege**: каждый компонент должен иметь минимальные необходимые права.
**Принцип наименьшего удивления** (*Principle of Least Astonishment*): поведение должно соответствовать ожиданиям пользователя.
**Принцип открытости/закрытости** (*open/closed principle*): код должен быть открыт для расширения, но закрыт для модификации.
**good enough** — минимально достаточное решение текущей задачи
**Подход Златовласки** (*Goldilocks principle*) — оптимальное решение задачи (решение должно быть достаточно простым для реализации и поддержки, но достаточно мощным для решения задачи)
**Алгоритм страуса** (*ostrich algorithm*) — это подход, при котором редкие или маловероятные проблемы сознательно игнорируются.
**Кодовая близость** (*code proximity*) — взаимосвязанные функции должны находиться недалеко друг от друга.
**Текучий интерфейс** (fluent interface) — это стиль проектирования, при котором методы объекта возвращают объект, позволяя вызывать несколько методов последовательно в одной цепочке вызова (*method chaining*)
**EAFP** (*easy to ask for forgiveness than permission* — проще попросить прощения, чем спрашивать разрешение) — стиль программирования, при котором конструкции try превалируют над if.
**LBYL** (*look before you leap* — не зная броду не суйся в воду) — стиль программирования, который подразумевает проверку предусловий до вызовов и характеризуется наличием многочисленных if.
**WYSIWG** (*what you see is what you get*) — что видишь, то и получаешь.
**UAP** (*Uniform Access Principle*) — принцип единообразного доступа Мейера гласит, что снаружи объекта должно быть все равно, что скрыто за его интерфейсом.


# Содержание

[1. Общие сведения о Python](#общие-сведения-о-python)
[2. Дзен Питона](#дзен-питона)
[3. `PEP`](#pep)
[4. `PIP` и `Poetry`](#pip-и-poetry)
[5. Документация](#документация)
[6. Синтаксис](#синтаксис)
[7. Мутабельность и хешируемость](#мутабельность-и-хешируемость)
[8. Тип `None`](#тип-none)
[9. Ellipsis](#ellipsis)
[10. Логические значения `bool`](#логические-значения-bool)
[11. Числовые типы](#числовые-типы)
[12. Целые числа `int`](#целые-числа-int)
[13. Рациональные числа `Fraction`](#рациональные-числа-fraction)
[14. Вещественные числа `float`](#вещественные-числа-float)
[15. Специальные значения `inf` и `nan`](#специальные-значения-inf-и-nan)
[16. Десятичные числа `Decimal`](#десятичные-числа-decimal)
[17. Комплексные числа `complex`](#комплексные-числа-complex)
[18. Строки `str`](#строки-str)
[19. `BOM`](#bom)
[20. Байтовые данные и бинарные структуры](#байтовые-данные-и-бинарные-структуры)
[21. Файлы](#файлы)
[22. Составные типы](#составные-типы)
[23. Списки `list`](#списки-list)
[24. Кортежи `tuple`](#кортежи-tuple)
[25. Множества `set`](#множества-set)
[26. Словари `dict`](#словари-dict)
[27. Массивы](#массивы)
[28. Двусторонние очереди](#двусторонние-очереди)
[29. Распределение памяти](#распределение-памяти)
[30. Представление типов в памяти](#представление-типов-в-памяти)
[31. Сборка мусора](#сборка-мусора)
[32. Области видимости](#области-видимости)
[33. Импорт](#импорт)
[34. Функции](#функции)
[35. Рекурсия](#рекурсия)
[36. Декораторы](#декораторы)
[37. Парсинг](#парсинг)
[38. Компиляция](#компиляция)
[39. Объект кода](#объект-кода)
[40. Кэширование](#кэширование)
[41. Выполнение](#выполнение)
[42. Отладка](#отладка)
[43. Профайлинг](#профайлинг)
[44. Исключения](#исключения)
[45. Классы и объекты](#классы-и-объекты)
[46. Проектирование классов](#проектирование-классов)
[47. `MRO`](#mro)
[48. Атрибуты](#атрибуты)
[49. Специальные методы](#специальные-методы)
[50. Дескрипторы](#дескрипторы)
[51. Свойства](#свойства)
[52. Слоты](#Слоты)
[53. Интерфейсы и абстрактные классы `ABC`](#интерфейсы-и-абстрактные-классы-ABC)
[54. Виртуальные подклассы](#виртуальные-подклассы)
[55. Протоколы](#протоколы)
[56. Метапрограммирование](#метапрограммирование)
[57. ооооо](#ооооо)
[58. ооооо](#ооооо)
[59. ооооо](#ооооо)


## Общие сведения о Python

**Python** — высокоуровневый язык программирования общего назначения с **динамической строгой типизацией** (*dynamic strong typing*). Код пишется не для типов объектов, а для их интерфейсов (*duck typing* — утиная типизация). Переменные и объекты хранятся в разных областях памяти и связываются ссылками (связать одну переменную с другой невозможно).

Использует **автоматическое управление памятью** (*automatic memory management*). Сборка мусора реализована с помощью **счётчика ссылок** (*reference counting*) и **циклического сборщика мусора** (*garbage collector*). Python полностью **объектно-ориентированный** (*object-oriented*). В стандартную библиотеку входит множество инструментов (*batteries included*). 


## Дзен Питона

**Дзен Питона** — это набор принципов, сформулированный Тимом Петерсом как философия языка Python. Он состоит из 19 кратких афоризмов, которые определяют стиль и идеологию Python. Чтобы вывести их можно выполнить `import this`:

```
1. Beautiful is better than ugly (красивое лучше, чем уродливое)
2. Explicit is better than implicit (явное лучше, чем неявное)
3. Simple is better than complex (простое лучше, чем сложное)
4. Complex is better than complicated (сложное лучше, чем запутанное)
5. Flat is better than nested (плоское лучше, чем вложенное)
6. Sparse is better than dense (разреженное лучше, чем плотное)
7. Readability counts (читаемость имеет значение)
8. Special cases aren't special enough to break the rules (частные случаи недостаточно особенные, чтобы нарушать правила)
9. Although practicality beats purity (хотя практичность важнее строгости)
10. Errors should never pass silently (ошибки не должны замалчиваться)
11. Unless explicitly silenced (разве что явно подавлены)
12. In the face of ambiguity, refuse the temptation to guess (в условиях неоднозначности не поддавайся искушению угадать)
13. There should be one-- and preferably only one --obvious way to do it (должен быть один — и желательно только один — очевидный способ сделать это)
14. Although that way may not be obvious at first unless you're Dutch (хотя он может быть неочевиден с первого взгляда, если вы не голландец)
15. Now is better than never (сейчас лучше, чем никогда)
16. Although never is often better than *right* now (хотя никогда часто лучше, чем прямо сейчас)
17. If the implementation is hard to explain, it's a bad idea (если реализацию сложно объяснить — это плохая идея)
18. If the implementation is easy to explain, it may be a good idea (если реализацию легко объяснить — это может быть хорошей идеей)
19. Namespaces are one honking great idea -- let's do more of those! (пространства имён — великолепная идея! Давайте использовать их чаще)
```


## `PEP`

**PEP** (*Python Enhancement Proposal*) — это документ, в котором предлагаются изменения, улучшения или стандарты для языка Python, его библиотеки, стиля кода или процесса разработки. PEP-ы — это основа официальной эволюции языка. Они являются **источником истины** (*source of truth*) при изучении, стандартизации и развитии Python. Публикуются на официальном сайте:

📎 https://peps.python.org

Каждому `PEP` присваивается уникальный номер. Документы проходят обсуждение, утверждение или отклонения, и некоторые `PEP` становятся официальной частью языка. Виды PEP:

**Стандартизующие** (*Standards Track*) — описывают новые возможности языка, изменения синтаксиса, стандартные библиотеки и API.
**Информационные** (*Informational*) — дают рекомендации и справочные материалы (например, по стилю).
**Процессные** (*Process*) — описывают процессы разработки и управления Python-сообществом.

Наиболее известные `PEP`:

**`PEP 8`** — стиль оформления кода Python  
**`PEP 20`** — *The Zen of Python* (философия языка)  
**`PEP 257`** — соглашения по докстрингам  
**`PEP 484`** — аннотации типов  
**`PEP 517/518`** — стандартизация `pyproject.toml`  
**`PEP 572`** — оператор присваивания `:=` (*walrus operator*)  
**`PEP 695`** — параметризация типов в классах (Python 3.12+)


## `PIP` и `Poetry`

**`pip`** — это стандартный инструмент для установки внешних пакетов. Он позволяет загружать и устанавливать библиотеки из **Python Package Index** (PyPI), а также из локальных архивов или удалённых репозиториев.

```bash
pip install requests             # установка пакета
pip install pandas==2.2.1        # установка конкретной версии
pip uninstall numpy              # удаление пакета
pip freeze > requirements.txt    # зафиксировать текущие зависимости
pip install -r requirements.txt  # установить зависимости из файла
```

**`Poetry`** — инструмент для управления зависимостями и публикации пакетов. Он объединяет функции `pip`, `venv` и `setuptools`, обеспечивая изолированную и воспроизводимую среду.

```bash
poetry new myproject         # создать новый проект
poetry init                  # инициализировать в существующей директории
poetry install               # установить зависимости
poetry add requests          # добавить зависимость
poetry update                # обновить зависимости
poetry run python script.py  # запуск в виртуальном окружении
```


## Документация

Модули, классы, функции и методы можно документировать прямо в коде — через **докстроки** (*docstrings*). Докстрока помещается первой в теле модуля, класса или функции, она становится значением атрибута `__doc__` и доступна для инспектирования во время выполнения кода. Эта документация доступна с помощью функции `help` или через IDE (используют для подсказок). Рекомендации по написанию документации находятся в `PEP 257`. Существуют готовые инструменты, которые конвертируют докстроки в полноценную документацию: `Sphinx`, `pdoc`, `mkdocstrings`, `pydoctor`.

**`doctest`** — это модуль в стандартной библиотеке, который позволяет писать тестируемые примеры прямо в докстроках. Эти примеры выглядят как интерактивная сессия Python, и doctest может автоматически запускать их и проверять, совпадают ли результаты.

**`dir`** — возвращает список  всех атрибутов, доступных в объекте. Не выводит некотрые специальные атрибуты, например, `__mro__`, `__bases__`, `__name__`. Если вызвать без аргументов, то вернет имена из текущей области видимости.


## Синтаксис

 Некоторые слова зарезервированны и вшиты в синтаксис.  **Конструкции языка** (*statements*) содержат **выражения** (*expressions*), которые состоят из **операций**, включающих **операторы**, **операнды** и **литералы**. Выражения должны возвращать хотя бы одно значение. Выражения могут выглядеть как конструкции, но конструкции нельзя использовать в качестве выражений (например, нельзя встраивать присваивания = в другие выражения). Конец строки обычно завершает конструкцию. С помощью разделителя (*statement separator*) `;` можно размещать несколько конструкций в одну строку, но составные конструкции (*compound statements*) все равно требуют собственных строк. Одиночные выражения внутри любых парных скобок (*syntactic pair* — синтаксическая пара) можно разбивать на несколько строк. Если конструкция содержит только одно выражение, то ее можно записать в одну строку:

```python
>>> if x > 0: print(x)
```

Присваивания создают ссылки на объекты, но не копируют их, поэтому переменные похожи на указатели. Соглашение об именовании:

**`_x`** — **приватное по соглашению** не импортируется при `from module import *`.
- **`__x`** — **псевдоприватное имя**  превращается в `_ИмяКласса__x` при декорировании имён (*name mangling*), чтобы избежать конфликтов в подклассах
- **`__x__`** — **магические имена** зарезервированы самим интерпретатором

Поскольку объект создается раньше переменной, то правильнее говорить, что переменная присвоена объекту, а не наоборот. В случае наличия указания нескольких переменных на один и тот же объект образуются синонимы (*aliases*). У каждого объекта есть идентификатор, тип и значение.

`==` — **проверка равенства** (*identity*) значений объектов (синтаксический сахар для метода `__eq__`)
`is` — **проверка тождественности** (*equality*) идентификаторов объектов работает быстрее проверки равенства потому что сравнение сводится к сравнению двух целых чисел
`id()` — получение идентификатора объекта (в CPython это адрес в памяти, но в других реализациях это может быть что-то другое)
`_` — хранит результат последнего выражения в интерактивном сеансе

Импортирование модулей, определения функций и классов, переменные циклов и аргументы функций являются неявными присваиваниями (*implicit assignments*). Существует несколько вариантов присваиваний:

`a += 1` — **составное присваивание** (*augmented assignment*) допускает конкатенацию и работает быстрее классического за счет того, что объект оценивается только один раз и изменения происходят на месте.
`a = b = "spam"` — **групповое присваивание** (*multiple-target assignment*)
`a, b = ["spam", "eggs"]` — **позиционное присваивание списка** (*positional list assignment*)
`a, b, c, d = "spam"` — **присваивание последовательности** (*sequence assignment*)
`a, *b = 'spam'` — **расширенная распаковка последовательности** (*extended sequence unpacking*) является шаблоном "первый, потом остальные" (*first, rest*) и создает список.
`*a, b = "spam"` — шаблон "остальные, последний" (*rest, last*)
`a, *b, c  = "spam"` — можно и так
`a, b, c = range(3)` — и так

Поведение составного присваивания зависит от типа первого операнда. Например, если объект изменяемый, то он поддерживает `__iadd__` (*in-place addition*), который будет вызван, иначе используется `__add__`. В зависимости от этого идентификатор объекта остается тем же самым или изменяется. Составное присваивание не является атомарной операцией.

**Распаковка** работает для любого итерируемого объекта (*iterable unpacking*). Формы распаковки: **параллельное присваивание** (*parallel assignment*), в том числе с использованием `*`, обмен значений двух переменных:

```python
a, b, c = [1, 2, 3]
a, *b, c = [1, 2, 3, 4, 5]
x, y = 5, 10
```

**Перегрузка операторов** (*operator overloading*) позволяет применять инфиксные (*infix operators*, например `+`, `-`, `*`), унарные (`unary operators`, например `-obj`, `~obj`) и некоторые другие операторы к объектам пользовательских типов. Это обычно используется для эмуляции чисел, коллекций и других встроенных типов. Нельзя перегружать операторы `is`, `and`, `or`, `not`, а также нельзя изменить поведение встроенных типов или создать новые операторы. Для перегрузки оператора достаточно реализовать соответствующий специальный метод в классе, например, `__add__`, `__eq__`, `__len__`. Метод должен принимать `self` и, при необходимости, `other`, и возвращать корректный результат. Логика метода может быть произвольной, но он не должен изменять операнды.

Конструкция `print` предоставляет интерфейс к стандартному потоку вывода (перенастраивается через sys.stdout, но можно использовать любой объект с методом write). В одиночном print тоже можно указать поток вывода, а можно обращаться напрямую к потоку:

```python
>>> sys.stdout.write("hello")
hello5
```

Утверждение `if` допускает множественное ветвление (*multiway branching*) и называется конструкцией потока управления (*controlflow statements*).

Примыкающие друг к другу строковые литералы (*string literals*) конкатенируются:

```python
>>> "a" "b"
"ab"
```

Циклы `for` используют итераторы `C`, а `while` работает со скоростью байткода, поэтому выполняется медленнее. Для `for` цель присваивания может быть любого типа. По окончании for счетчик продолжает ссылаться на последний элемент. Существует функции для работы с итерацией:

**`break`** — переходит за пределы текущего цикла
**`continue`** — переходит в начало текущего цикла
**`else`** — выполняется только когда поток покинул цикл без использования break (позволяет не использовать флаг состояния) или если тело цикла ни разу не выполнялось

В циклах `for` и `while` допускается конструкция `else`, которая выполняется только если цикл завершился без использования `break`: в `for` — когда цикл дошёл до конца и не был прерван досрочно, в `while` — если условие стало ложным, а не произошло преждевременного выхода.


## Мутабельность и хешируемость

**Мутабельность** (`mutability`) — это способность объекта изменяться после создания. В Python объекты бывают изменяемыми (`mutable`) и неизменяемыми (`immutable`). Мутабельность относится к объекту, а не к переменной. Переменные — это ссылки, и если две ссылки указывают на один изменяемый объект, изменения объекта будут затрагивать их обе. В целях оптимизации CPython использует **разделение строковых литералов** (*sharing of string literals*), также называемое **интернированием** (*interning*). То есть вместо создания новых копий, интерпретатор может повторно использовать уже существующие объекты, создавая дополнительные ссылки на них.

Неизменяемые типы: `int`, `float`, `bool`, `str`, `tuple`, `frozenset`, а также все объекты, которые не предоставляют интерфейса для изменения своего состояния. Изменение таких объектов приводит не к их модификации, а к созданию новых объектов. Например, при конкатенации создаётся новая строка, а не изменяется исходная. Только неизменяемые объекты можно использовать как ключи в словарях и элементы множеств, так как их хэш остается постоянным.

Изменяемые типы: `list`, `dict`, `set`, `bytearray`, а также большинство пользовательских объектов. Они изменют своё состояние без изменения своей идентичности (`id`).

Хешируемость (*hashability*) — это свойство объекта, при котором он имеет стабильное значение, вычисляемое функцией `hash()`. То есть метод `__hash__` обязан возвращать одно и то же значение на протяжении всей жизни объекта независимо от его состояния. При этом должно поддерживаться сравнение на равенство (`==`), соблюдая при этом правило: если `a == b`, то обязательно `hash(a) == hash(b)`.

Хешируемыми являются все атомарные объекты: числа, строки, байты. Кортежи считаются хешируемыми только в том случае, если все их элементы тоже хешируемы. Пользовательские объекты по умолчанию хешируемы, так как их хэш равен `id`, но если определяется метод `__eq__`, необходимо также явно определить `__hash__`, чтобы сохранить логическое соответствие: если `a == b`, то `hash(a) == hash(b)`.


## Тип `None`

`None` — единственный экземпляр типа `NoneType`, обозначающий отсутствие значения. Интерпретируется как `False`. Он возвращается, если функция ничего не возвращает явно. Также используется для аргументов, чтобы отличить "не передано" от "передано явно", и может служить признаком того, что переменная ещё не определена. `None` обычно используется как заполнитель в структурах данных.

Сравнивать с `None` следует через `is`, а не `==`, так как `None` — синглтон, и важно проверять идентичность, а не равенство, которое может быть переопределено.

Тип `NoneType` не имеет доступных атрибутов и не может быть создан вручную (попытка вызвать `NoneType()` приведёт к ошибке).

## Ellipsis

**Ellipsis** (обозначается `...`) — это специальный встроенный объект с типом `ellipsis`, применяемый как заглушка в коде, в аннотациях типов (например, `Callable[..., int]`) и для сокращённой записи многомерных срезов (например, `array[..., 0]` в `NumPy`). Он представляет собой единственный экземпляр и используется там, где нужно явно указать "всё остальное" или "ещё не реализовано".


## Логические значения `bool`

Тип `bool` представляет логические значения и является подклассом `int` (его значения `True` и `False` это просто настроенные версии чисел `1` и `0`). Логические значения участвуют в арифметических операциях, могут использоваться как ключи в словарях и применяются во всех условных выражениях. Любой объект может быть приведён к `bool`, и его поведение в логических выражениях определяется методами `__bool__()` или `__len__()`, если они реализованы.

Функция `bool(x)` приводит объект x к логическому значению. Ложными считаются: `None`, `False`, `0`, `0.0`, `0j`, а также пустые строки, коллекции и диапазоны.

При любых проверках на истинность возвращается не `True` или `False`, а объект левого или правого операнда. При проверке `or` объекты проверяются слева направо, возвращается первый истинный объект, а дальнейшая проверка не производится (*short-circuit evaluation*). В случае `and` проверка также производится слева направо и останавливается когда находится ложный объект. Это используется для выбора непустого объекта из набора фиксированного размера:

```python
>>> a = b or default
```

Оператор `not` всегда возвращает логическое значение:

```python
not 0     # True
not "hi"  # False
```


## Числовые типы

**Натуральные числа** (ℕ, *natural numbers*) — это числа, используемые при счёте: 1, 2, 3, 4, … (в некоторых определениях — включая 0). Они замкнуты относительно сложения и умножения, но не вычитания.

**Целые числа** (ℤ, *integers*) включают ноль, положительные и отрицательные числа без дробной части: ..., −2, −1, 0, 1, 2, .... Они замкнуты относительно сложения, вычитания и умножения, но не деления: результат деления двух целых чисел не всегда целое число. Соответствуют типу `int`.

**Рациональные числа** (ℚ, *rational numbers*) — это числа, которые можно представить в виде дроби `m/n`, где `m` и `n` — целые числа, а `n ≠ 0`. Определены сложение, вычитание, умножение и деление (кроме деления на ноль). В Python соответствуют типу `fractions.Fraction`.

**Вещественные числа** (ℝ, *real numbers*) включают рациональные и иррациональные числа — те, которые не могут быть выражены в виде дроби (например, √2, π). Это непрерывное (*continuous*) множество, используемое для измерения величин. ℝ не счётно и не замкнуто в конечной точности — любое приближённое представление вещественного числа всегда ограничено. В Python соответствуют типу `float`.

**Комплексные числа** (ℂ, *complex numbers*) имеют вид `a + bi`, где `a` и `b` — вещественные числа, а `i` — мнимая единица (*imaginary unit*, `i² = −1`). Множество ℂ замкнуто относительно всех основных арифметических операций и содержит все корни многочленов с вещественными коэффициентами (в отличие от ℝ). В Python соответствуют типу `complex`.

Приоритет основных операций по убыванию: `**`, `/`, `*`, `-`, `+`, `==`, `in`, `not`, `and`, `or`. В выражениях с разнородными числовыми типами операнды преобразуются к типу самого сложного.

Допускаются **сцепленные сравнения** (*chained comparisons*):
```python
1 < 2 < 3
```


### Целые числа `int`

Тип `int` представляет **целые числа** произвольной длины. В Python 3 их размер ограничен только доступной памятью. Это неизменяемый (`immutable`) тип. Объекты создаются напрямую (`x = 42`) или через `int(x)` с преобразованием. Если аргумент — строка, можно указать систему счисления:

```python
>>> int('101', 2)
5
```

Отображаться целые числа также могут в разных системах счисления

```python
>>> hex(10)
'0xa'
>>> 0xa
10
```

Но независимо от формы записи, в памяти числа не меняются:

```python
>>> int(oct(10), 8) == int(hex(10), 16)
True
```

Поддерживаются стандартные арифметические операции (`+`, `-`, `*`, `//`, `%`, `**`) и побитовые (`&`, `|`, `^`, `~`, `<<`, `>>`).

**`abs(x)`** — модуль числа,
**`divmod(a, b)`** — пара (`a // b`, `a % b`),
**`pow(x, y, z)`** — возведение в степень с остатком по модулю
**`round(x)`** — округление  
**`bin(x)`**, **`oct(x)`**, **`hex(x)`** — строковые представления в других системах счисления

При **обычном делении** `/` двух целых чисел тип результата всегда `float`.

При **целочисленном делении** (*floor division*) `//` если хотя бы один из операндов типа `float`, результат тоже будет `float`. Кроме того, при целочисленном делении происходит округление с понижением (*floor rounding*), а не усечение:

```python
>>> 5.0 // 2
2.0
>>> -5.0 // 2
-3.0
```

Для ***деления с усечением*** (*truncating division*) требуется ручная обработка:

```python
>>> int(-5.0 / 2)
-2
```

Для целых чисел доступны операции, которые трактуют их как строки двоичных битов:

```python
>>> 1 << 2  # сдвиг влево на 2 бита: 0100
4
>>> 1 | 2   # побитовое ИЛИ: 0011
3
>>> 1 & 1   # побитовое И: 0001
1
```


## Рациональные числа `Fraction`

Тип `fractions.Fraction` представляет **рациональные числа** (*rational numbers*). Они в явном виде хранят числитель и знаменатель. `Fraction` всегда сокращает дроби до наименьших числителей и знаменателей, поддерживает все стандартные арифметические операции и сравнение, может быть создан из целых чисел, строк и `float` (но при этом возможна потеря точности), а также обеспечивает точные вычисления с минимизацией ошибок округления.

```python
>>> from fractions import Fraction
>>> 1 + 1.0 + Fraction(1, 2)
2.5
```

Их можно получить из чисел с плавающей точкой:

```python
>>> a = 0.5
>>> Fraction(*a.as_integer_ratio())
Fraction(1, 2)
```


## Вещественные числа `float`

Тип `float` представляет **вещественные числа** (*real numbers*). Они записываются с точкой (`3.14`, `-0.001`) или в экспоненциальной форме в виде мантиссы (`mantissa`) и показателя степени (`exponent`) при основании `10`:

```python
>>> 2e+3
2000.0
```

Это неизменяемый (`immutable`) тип. Создаётся напрямую или через `float(x)`, где `x` — число, строка или объект с поддержкой преобразования. Тип `float` обладает **двойной точностью** (*double precision*), при котором на хранение значения отводится 64 бита (8 байт). Этот формат соответствует стандарту `IEEE 754` и обеспечивает примерно 15–17 значащих цифр десятичной точности. Ограниченная точность может вызывать ошибки округления:

```python
>>> 1.1 + 2.2
3.3000000000000003
```

Поддерживаются те же операции, что и для `int`, включая деление `/`, которое всегда возвращает `float`, даже если делится два целых числа. Операторы `//` и `%` при работе с `float` могут давать неожиданные результаты из-за особенностей округления.

`round(x, ndigits)` — округление

`math.isclose(a, b)` — сравнение с учётом погрешности

`math.isnan(x)`, `math.isinf(x)` — используются для проверки на специальные значения: не число (`nan`) и бесконечность (`inf`)


## Специальные значения `inf` и `nan`

Тип `float` включает два специальных значения: бесконечность (`inf`, *infinity*) и не число (`nan`, *not a number*). То есть `inf` и `nan` входят в стандартный тип `float`.

`inf` и `-inf` представляют положительную и отрицательную бесконечность соответственно, создаются через `float('inf')` и `float('-inf')`. Значение `inf` можно сравнивать: `inf > 1e100` даст `True`.

`nan` обозначает неопределённый или некорректный результат вычислений. Его можно создать как `float('nan')`. Особенность `nan` в том, что оно не равно даже самому себе: `nan != nan`. Для проверки используется функция `math.isnan(x)`. `nan` часто используется для представления ошибок вычислений или отсутствующих данных.


## Десятичные числа `Decimal`

Тип `decimal.Decimal` имеет фиксированное количество разрядов (*fixed-precision*) после десятичной точки и используются когда важна высокая точность вычислений (например, в финансовых расчётах). Он определяется в модуле `decimal`, который нужно явно импортировать. Объекты `Decimal` создаются из строк, чтобы избежать ошибок двоичного округления:

```python
Decimal("0.1") + Decimal("0.2") == Decimal("0.3")  # True
```

При создании из `float` теряется точность:

```python
>>> Decimal(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')
```

Если в выражении десятичные числа разной точности, результат преобразуется к наибольшему количеству десятичных цифр:

```python
>>> Decimal('1.0') + Decimal('1.000')
Decimal('2.000')
```

Преимуществами `Decimal` являются высокая точность без накопления ошибок округления, предсказуемое поведение при сравнении и сложении, а также возможность настройки арифметики через контекст. К недостаткам можно отнести меньшую производительность по сравнению с `float`.

Тип `Decimal` поддерживает все основные арифметические операции и работает вместе с `int`, но его не следует смешивать с `float`, чтобы избежать потери точности. Поведение вычислений зависит от текущего контекста (`decimal.getcontext()`), который определяет правила работы с числами типа `Decimal`. Он задаёт точность вычислений (количество значащих цифр), режим округления (вверх, вниз, к ближайшему), а также поведение при переполнении, делении на ноль, потере точности и других исключениях.


## Комплексные числа `complex`

Комплексные числа представлены типом `complex`. Это встроенный тип, значения записываются в виде `a + bj`, где `a` — действительная часть, `b` — мнимая, а `j` — обозначение мнимой единицы (в отличие от математики, где обычно используют `i`). Мнимая часть может быть целым или дробным числом: `1j`, `2.5j`, `3 + 4j`.

Комплексные числа поддерживают арифметические операции: сложение, вычитание, умножение, деление, возведение в степень. Операторы `==` и `!=` допустимы, но операторы порядка (`<`, `>`, `>=`, `<=`) не поддерживаются и вызывают `TypeError`.

У комплексного числа доступны свойства `real` и `imag` для получения действительной и мнимой частей, функция `abs(z)` возвращает модуль (длину), а метод `conjugate()` — сопряжённое значение.

Модуль `cmath` предоставляет расширенные математические функции для работы с комплексными числами: тригонометрию, экспоненту, логарифмы и другие:

```python
import cmath
cmath.sqrt(-1)  # 1j
```

## Строки `str`

**Строка** `str` — неизменяемая последовательность символов. В памяти Python хранит декодированные строки в нейтральном к кодировкам (*encoding-neutral*) формате `Unicode`, где каждый элемент — это символ, а не байт. Он имеет кодовую позицию (*code point*) — целое число в шестнадцатеричном виде с префиксом `U+` (например, `U+00E9` для символа `é`). Кодировки поддерживаются модулем `encodings` и применяются только для передачи и хранения в файлах:

**`ASCII`** — набор символов с кодами 0-127 (`7 бит`, 1 байт на символ), является подмножеством остальных кодировок
**`Latin-1`** — набор символов с кодами 0-255 (`8 бит`, 1 байт на символ)
**`UTF-8`** — набор символов переменного размера (на каждый символ выделяется фиксированное количество `1`, `2` или `4` байта в соответствии с наибольшим порядковым значением `Unicode` в данной строке)

Процесс преобразования в байты — **кодирование** (*encoding*), а обратно — **декодирование** (*decoding*). Переменная среды `PYTHONIOENCODING` устанавливает кодировку по умолчанию для стандартных потоков. Кодировка байтовой последовательности не всегда очевидна и должна задаваться явно. В случае неизвестной кодировки можно использовать эвристические инструменты, например, библиотеку `chardet`. Первой строкой в `.py`-файлах можно указывать кодировку в явном виде:

```python
# -*- coding: utf-8 -*-
```

Строки поддерживают конкатенацию (*concatenation*) `'a' + 'b'`, повторение (*repetition*) `'a' * 3`, индексацию (*indexing*), срезы (*slicing*) `s[1:3]` включающее (*inclusive*) левую границу и исключающее (*noninclusive*) правую, поиск и замену `s.find()` и `s.replace()`, разбиение и соединение `s.split()` и `', '.join(list)`, изменение регистра `s.upper()` и `s.lower()`, проверку начала и конца `s.startswith()` и `s.endswith()`, преобразование в кодовые точки и обратно `ord` и `chr`, проверку содержимого `isdigit`, `isalpha`, `isalnum`.

Расширенное нарезание (`extended slicing`) дополнительно принимает страйд (*stride*), который добавляется к индексу каждого извлеченного элемента и может использоваться для обращения порядка:

```python
>>> 'spam'[::2]
'sa'
>>> 'spam'[::-1]
'maps'
```

Форматирование строк:
f-строки (начиная с Python 3.6): `f"Hello, {name}!"`  
Метод `str.format()`: `"{} {}".format(a, b)`  
Старый стиль: `"%s %d" % (a, b)`

## `BOM`

`BOM` (*byte-order mark*) — это специальная последовательность байтов, которая может находиться в начале текстового файла и служит для указания кодировки текста и порядка байтов (*endianness*). Сам `BOM` не является частью содержимого строки, но может повлиять на её обработку, особенно при чтении или сравнении:

```
| Кодировка   | BOM         |
|-------------|-------------|
| UTF-8       | EF BB BF    |
| UTF-16 (BE) | FE FF       |
| UTF-16 (LE) | FF FE       |
| UTF-32 (BE) | 00 00 FE FF |
| UTF-32 (LE) | FF FE 00 00 |
```

`BOM` в `UTF-8` не требуется и используется редко — в основном в системах `Windows`. В `UTF-16` и `UTF-32` он важен, так как без него невозможно определить порядок байтов: `big-endian` (старший байт записывается первым) или `little-endian` (младший байт записывается первым).

Наличие `BOM` в файле может вызвать проблемы: например, `open()` по умолчанию не удаляет `BOM` при чтении в `utf-8`, и он остаётся в начале строки. Для безопасного чтения таких файлов можно использовать кодировку `utf-8-sig`, которая автоматически удаляет `BOM`:

```python
with open("file.txt", encoding="utf-8-sig") as f:
    text = f.read()
```

## Байтовые данные и бинарные структуры

Для работы с низкоуровневыми двоичными данными существует два типа: `bytes` — неизменяемая последовательность двоичных целых чисел (`0-255`); `bytearray` — изменяемый вариант `bytes` (поддерживает многие списковые операции изменения на месте). Они используются, например, при кодировании строк (`s.encode('utf-8')`) и при чтении бинарных файлов. Эти типы поддерживают индексацию, срезы, сравнение, большинство строковых методов (кроме форматирования), а также специфические методы: `hex()`, `fromhex()` и др.

Модуль `struct` позволяет упаковывать и распаковывать бинарные данные в соответствии с заданным форматом. Это удобно для представления структур, аналогичных тем, что используются в языках низкого уровня, таких как `C`.

```python
import struct
data = struct.pack('<I2s', 1024, b'OK')  # Little-endian: int + 2 байта
num, msg = struct.unpack('<I2s', data)
```

Модуль `re` поддерживает работу с байтовыми строками, если шаблон также задан в байтовом виде. Это полезно при поиске бинарных паттернов (например, сигнатур в файлах).

Тип `memoryview` предоставляет доступ к данным `bytes`, `bytearray`, `array` и другим буферным объектам без копирования. Он позволяет эффективно обрабатывать большие массивы данных или потоковые фрагменты, изменяя их напрямую.

Эти инструменты особенно полезны при работе с сетевыми протоколами, бинарными форматами и низкоуровневым вводом-выводом.

## Файлы

Файловый тип в Python — это тип объектов, представляющих открытые файлы, обычно создаваемых функцией `open()`. Он реализован как класс `TextIOWrapper` для текстовых файлов или `BufferedReader`/`BufferedWriter` для бинарных. Файловый объект автоматически освобождает ресурсы при сборке мусора, но рекомендуется использовать менеджер контекста (*context manager*) `with`. Файл может быть открыт в текстовом (`r`, `w`) или бинарном (`rb`, `wb`) режиме, что влияет на возвращаемые/принимаемые типы (`str` или `bytes`). Файлы буферизуются (*buffered*) и поддерживают позиционирование (*seekable*). Для чтения следует использовать файловый итератор (*file iterator*), а не читать файл целиком. Для работы с файлами используются строки, автоматического преобразования из других типов не происходит.

Для работы с произвольными типами используются модули `pickle` или `json`, которые сериализует объекты (*object serialization*):

**`pickle.dump`** — сохранение любого объекта
**`pickle.load`** — загрузка любого объекта
**`json.dumps`** — сериализация объекта в строку формата JSON
**`json.loads`** — десериализация объекта

## Составные типы

**Составные типы** (*container types*) представляют собой структуры, содержащие несколько элементов. Они реализованы в виде последовательностей, множеств и отображений, но принцип один: такие объекты хранят не отдельное значение, а совокупность данных, к которым можно получить доступ по индексу, ключу или через перебор.

Последовательности делятся на два рода. В **контейнерных** (*container sequences*) — таких как `list`, `tuple` или `collections.deque` — хранятся ссылки на объекты любого типа. А в **плоских** (*flat sequences*), таких как `str`, `bytes`, `bytearray`, `memoryview` и `array.array`, — хранятся значения непосредственно, как атомарные данные.

Также различают **изменяемые** (*mutable sequences*) и **неизменяемые** (*immutable sequences*). К первым относятся `list`, `bytearray`, `array.array`, `collections.deque`, `memoryview`; ко вторым — `tuple`, `str` и `bytes`.

## Списки `list`

**Списки** `list` — это упорядоченные коллекции (*ordered collections*) произвольных объектов (по сути массивы ссылок на объекты). Элементы могут быть любого типа, включая другие списки. Списки допускают повторения, позволяют обращаться к элементам по индексу и поддерживают срезы, перебор, сравнение и множество встроенных операций. Метод `sort` упорядочивает список на месте, но допускает сортировку элементов только одного типа. Присваивание по индексу (*index assignment*) заменяет ссылку объект. Любые изменяемые последовательности, в том числе списки, с помощью срезов можно расширять (`graft`), схлопывать (`excise`) и изменять на месте (`in-place`):

```python
>>> a = [1, 2, 3, 4]
>>> a[1:3] = ["a", "b"]
>>> a
[1, 'a', 'b', 4]
```

Создать список можно с помощью квадратных скобок: `a = [1, 2, 3]`, пустой список — `[]`. Также список можно создать через `list(iterable)`, преобразовав любой итерируемый объект.

Списки поддерживают индексацию (`a[0]`), срезы (`a[1:3]`), замену элементов (`a[0] = 42`), добавление (`a.append(x)`, `a.extend(seq)`, `a += seq`), вставку (`a.insert(i, x)`), удаление (`del a[i]`, `a.remove(x)`, `a.pop()`), разворот (`a.reverse()`), сортировку (`a.sort()`), копирование (`a.copy()`, `a[:]`) и подсчёт (`a.count(x)`, `a.index(x)`).

Важно, что присваивание `b = a` не создаёт копию списка, а лишь новую ссылку на тот же объект. Для независимой копии следует использовать `a.copy()` или `list(a)`.

При копировании с помощью конструктора `b = list(a)` или среза создаётся поверхностная копия (*shallow copy*): дублируется только внешний контейнер, а его элементы продолжают ссылаться на те же объекты. Для полной независимой копии используется `copy.deepcopy()`, но он также копирует вложенные объекты, включая ссылки на внешние ресурсы — это не всегда желательно.

Списки можно сравнивать лексикографически: сначала сравниваются первые элементы, затем вторые и так далее. Элементы при этом должны быть сравнимы между собой — иначе возникнет `TypeError`. Перебор выполняется стандартным образом: `for x in a`.

Списковые включения (*list comprehensions*) работают быстрее циклов:

```python
>>> [x for x in 'spam!' if x.isalpha()]
```

## Кортежи `tuple`

**Кортежи** являются упорядоченными неизменяемыми (но допускают вложение изменяемых объектов) коллекциями (*ordered collections*) и поддерживают доступ по смещению (*accessed by offset*).
Создать кортеж можно с помощью запятой: `t = 1, 2, 3`. Рекомендуется заключать его в скобки: `t = (1, 2, 3)`. Пустой кортеж записывается как `()`, а одноэлементный — с запятой: `(42,)`.

Кортежи поддерживают те же операции, что и списки: индексацию (`t[0]`), срезы (`t[1:]`), перебор (`for x in t`), объединение (`t1 + t2`), повторение (`t * 3`), а также сравнение. Однако большинство "изменяющих" методов в нём отсутствует.

Кортеж может содержать любые типы объектов, в том числе изменяемые. Однако, если сам кортеж используется как ключ в словаре или как элемент множества, все его элементы тоже должны быть хэшируемыми.

Часто кортежи используются для возвращения нескольких значений из функции или для упаковки-распаковки (`a, b = f()`).

Для более читаемых и самодокументирующихся структур существует тип `namedtuple` из модуля `collections`. Это расширение обычного кортежа, где каждому элементу присваивается имя. Такой объект ведёт себя как кортеж, но к значениям можно обращаться по именам:

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(3, 4)
print(p.x)  # 3
```

Объекты `collections.namedtuple` используют столько же памяти, сколько и обычные кортежи, поскольку имена полей хранятся в определении класса. Они также значительно компактнее, чем экземпляры обычных классов, потому что не содержат `__dict__` — все атрибуты фиксированы и не хранятся отдельно.

## Множества `set`

**Множество** — это неупорядоченная коллекция уникальных объектов. Хотя само оно изменяемо, но может содержать только неизменяемые объекты. Она не сохраняет порядок элементов и не допускает повторений: если при создании указать одинаковые значения, они автоматически будут удалены. Множества полезны, когда нужно проверять наличие элемента, исключать дубликаты или выполнять классические операции теории множеств.

Создать множество можно с помощью фигурных скобок, указав значения через запятую, например `{1, 2, 3}`. При этом пустое множество создаётся через `set()`, так как `{}` по умолчанию интерпретируется как пустой словарь. Также можно преобразовать любой итерируемый объект в множество с помощью конструктора `set()`.

Множества изменяемы: можно добавлять элементы методом `add()`, удалять с помощью `remove()` или `discard()`. Первый вызывает ошибку, если элемента нет, второй — нет. Метод `pop()` удаляет и возвращает произвольный элемент. Полностью очистить множество позволяет метод `clear()`.

Поддерживают операции пересечения (*intersection*), объединения (*union*), разности (*difference*), надмножества и подмножества (*superset*/*subset*):

```python
>>> set('abc') & set('cde')
{'c'}
>>> set('abc') | set('cde')
{'a', 'b', 'c', 'd', 'e'}
>>> set('abc') - set('cde')
{'a', 'b'}
>>> set('abc') > set('bc')
True
```

Если требуется неизменяемый вариант множества — например, для использования в качестве ключа в словаре — можно воспользоваться типом `frozenset`. Он ведёт себя как обычное множество, но не допускает модификации после создания.

## Словари `dict`

**Словари** являются неупорядоченными коллекциями (*unordered collections*) произвольных объектов (*arbitrary objects*). Относятся к изменяемым отображениям (*mutable mapping*). Не являются последовательностями, но поддерживают итерацию и могут имитировать списки. Представляют собой хеш-таблицы (*hash tables*). Поддерживают доступ по ключу (*accessed by key*), но сам ключ должен быть неизменяемым.

В основе словаря лежит **хеш-таблица**, обеспечивающая очень быструю вставку, поиск и удаление элементов — независимо от его размера. Это достигается за счёт значительных затрат памяти и требования, чтобы все ключи были хешируемыми: неизменяемыми и поддерживающими методы __hash__ и __eq__. Если объект может изменяться, он не должен использоваться в качестве ключа, иначе возможны ошибки и некорректное поведение.

Словарь создаётся с помощью фигурных скобок: `{"a": 1, "b": 2}` или через конструктор `dict()`. Пустой словарь — это `{}`. Обращение к значению по ключу выполняется как `d["key"]`, а безопасный доступ — через `d.get("key")`, который возвращает `None` (или значение по умолчанию), если ключ не найден. Элемент можно добавить или обновить с помощью присваивания, удалить — с помощью `del`, `pop()` или `popitem()`. Методы `keys()`, `values()` и `items()` возвращают итерируемые объекты представлений (*view objects*), которые предохраняют первоначальный порядок следования элементов и динамически отражают будущие изменения словаря. Словари поддерживают перебор, но порядок перебора не всегда совпадает с порядком вставки. Кроме того не следует изменять словарь во время итерации по нему.

Для формализации интерфейсов, совместимых с `dict`, модуль `collections.abc` предоставляет абстрактные базовые классы `Mapping` и `MutableMapping`. Проверить, соответствует ли объект поведению словаря, можно через `isinstance()`:

```python
from collections import abc
d = {}
isinstance(d, abc.Mapping)  # True
```

## Массивы

**Массивы** `array.array` могут хранить только однотипные значения. Это эффективная альтернатива спискам для хранения большого количества чисел одного типа. Поддерживают все операции над изменяемыми последовательностями и дополнительные методы для загрузки и сохранения. Массив создаётся с указанием кода типа (например, "i" для int, "f" для float):

```python
a = array.array("i", [1, 2, 3])
```

Массивы полезны, когда важна экономия памяти и типовая однородность, особенно при взаимодействии с `C`-кодом или двоичными файлами. В памяти занимают столько же места, как массивы в `C`. При числовой обработке работают быстрее списков.

## Двусторонние очереди

**Двусторонние очереди** (*double-ended queue*) оптимизированы для быстрого добавления и удаления элементов с обеих сторон за амортизированное `O(1)` время. Они подходят для реализации стеков, очередей и скользящих окон, особенно когда требуется работа с началом структуры (в отличие от списков, где это дорого). Поддерживают методы `append`, `appendleft`, `pop`, `popleft`, `extend`, `rotate` и другие. При задании параметра `maxlen` автоматически удаляют старые элементы при переполнении, что удобно для создания ограниченных буферов. Позволяют удобно создавать очереди `LIFO`.

## Распределение памяти

**Куча** (*heap*) — это область динамической памяти, где хранятся все объекты. Переменные содержат лишь ссылки, а сами объекты размещаются в куче. Память может выделяться и освобождаться в любом порядке.

За управление памятью отвечает собственный аллокатор **PyMalloc**, работающий поверх системного `malloc()` из `C`. `PyMalloc` — это аллокатор малых объектов (*small object allocator*), он используется для объектов размером **до 512 байт**.

Память в `PyMalloc` организована трёхуровнево: **арены** (*arena*) — крупные блоки по `256 КБ`, **пулы** (*pool*) — сегменты арены по `4 КБ` (предназначены для объектов одного размера) и **слоты** (*block*) — ячейки в пуле, в которые помещаются объекты (например, в один пул влезет 256 слотов по `16 байт` ).

При создании объекта **до 512 байт** `PyMalloc` ищет свободный слот нужного размера. Если подходящего пула нет — выделяется новый. Например, короткие строки часто хранятся в слотах по 56 байт.

Объекты **больше 512 байт** выделяются напрямую через **системный аллокатор** (*system malloc*) — это медленнее и менее эффективно. Такие объекты не делят память с другими: это снижает фрагментацию, но и ухудшает повторное использование. Освобождение происходит через `free()`, но оно лишь помечает память как доступную, не обязательно немедленно возвращая её ОС.

**`sys.getsizeof()`** — получить размер объекта в байтах.
**`sys.getrefcount()`** — получить количество ссылок на объект.


## Представление типов в памяти

Все объекты в памяти представляют собой структуры, содержащие служебную информацию и собственные данные. Даже элементарные значения реализованы как полноценные объекты и занимают больше места, чем может показаться. Каждый объект содержит минимальный заголовок, который может содержать: счетчик ссылок **ob_refcnt** (*reference counter*) и обозначение типа **tp_type** (*type designator*) — указатель на структуру `PyTypeObject`, **padding** — добавочные байты для выравнивания структуры до размера, кратного 8 (на 64-битных системах), нужно для корректного размещения в памяти

Тип `None` — это единственный объект `NoneType`, реализованный как структура `PyNoneObject`. Это синглтон, который занимает **16 байт**:

```
+---------------------------------+
| PyNoneObject                    |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
+---------------------------------+
```

Тип `bool` — это структура `PyBoolObject`, унаследованная от `PyLongObject`, которая существует в двух экземплярах: `True` и `False`. Каждый занимает **24 байт**:

```
+---------------------------------+
| PyBoolObject                    |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| padding                     4 B |
| ob_ival                     4 B |  0 или 1
+---------------------------------+
```

Тип `int` — это структура произвольной длины `PyLongObject`. Может представлять числа неограниченного размера. Хранит "цифры" в виде массива целых чисел `digit[]`, каждое из которых занимает **4 байта**. Для малых чисел всё помещается в один слот, но при увеличении добавляются ячейки. Занимает от **28 байт**:

```
+---------------------------------+
| PyLongObject                    |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| padding                     4 B |
| ob_size                     4 B |  число цифр и знак
| digit[]                 N * 4 B |  массив цифр числа
+---------------------------------+
```

Тип `float` — это структура фиксированного размера `PyFloatObject`. Хранит число в формате `IEEE 754` (64-битное число с плавающей точкой). Занимает **24 байта**:

```
+---------------------------------+
| PyFloatObject                   |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| ob_fval                     8 B |  значение в формате double
+---------------------------------+
```

Тип `str` — это структура переменной длины `PyUnicodeObject`. Строка хранится как массив символов `data[]`. Размер пустой строки составляет **49 байт**, при увеличении добавляется по **1–4 байта** на символ, в зависимости от диапазона (`Latin1`, `UCS-2`, `UCS-4`). Для `ASCII` используется компактное представление без избыточных полей.

```
+---------------------------------+
| PyUnicodeObject                 |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| padding                     1 B |
| state/flags/kind            4 B |
| length                      8 B |  количество символов
| hash                        8 B |  кеш хеш-значения
| data[]              N * (1-4) B |  массив символов Unicode
+---------------------------------+
```

Тип `tuple` — это неизменяемый массив ссылок на объекты. Он реализован как структура `PyTupleObject` с фиксированным числом элементов. Пустой кортеж занимает около **40 байт**, каждый элемент добавляет **по 8 байт** (указатель):

```
+---------------------------------+
| PyTupleObject                   |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| ob_size                     8 B |  количество элементов
| ob_item[]               N * 8 B |  массив указателей на элементы
+---------------------------------+
```

Тип `list` — это динамический массив ссылок на объекты. Объект `PyListObject` хранит длину и указатель на буфер `ob_item[]`, в котором лежат ссылки на элементы. Буфер может быть больше длины списка — это позволяет эффективно добавлять элементы без частого перераспределения. Пустой список занимает около **64 байт**, каждый элемент добавляет **8 байт**, но из-за буфера реальный размер больше.

```
+---------------------------------+
| PyListObject                    |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| allocated                   8 B |  размер выделенного буфера
| ob_size                     8 B |  количество элементов
| ob_item                     8 B |  указатель на ob_item[]
+---------------------------------+

+---------------------------------+
| ob_item[]                       |
+---------------------------------+
| ptr_0 (ссылка на obj0)      8 B |
| ptr_1 (ссылка на obj1)      8 B |
| ...                             |
+---------------------------------+
```

Тип `set` — это объект `PySetObject`, управляющий внутренней хеш-таблицей. Он хранит только ключи и их хеши (без значений) и состоит из двух блоков: сам `PySetObject` и внешний массив `entries[]`, где размещаются пары `hash` + `key`. Таблица `entries[]` может перевыделяться при росте, но структура `PySetObject` остаётся фиксированной по размеру.

Память выделяется с запасом, чтобы избежать коллизий и сохранить быстрый доступ. При достижении порога загрузки таблица автоматически расширяется, и все элементы перехешируются. Пустое множество занимает около **216 байт**. Все ключи должны быть хешируемыми и неизменяемыми:

```
+---------------------------------+
| PySetObject                     |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| used                        8 B |  число занятых ячеек
| fill                        8 B |  общее число ячеек
| mask                        8 B |  управляет размером таблицы
| hashseed                    8 B |  случайный сдвиг для защиты
| table                       8 B |  указатель на entries[]
| smalltable                 36 B |  встроенный буфер
+---------------------------------+

+---------------------------------+
| entries[]                       | 
+-------------------+-------------+
| hash(key0)    8 B | key0    8 B |
| hash(key1)    8 B | key1    8 B |
| ...               |             |
+-------------------+-------------+
```

Тип `dict` — это объект `PyDictObject`, управляющий хеш-таблицей пар ключ–значение. Он состоит из двух частей: сам объект и таблица `ma_keys`, содержащая массив записей `entries[]`. Ключи и значения хранятся раздельно: ключи — в `entries[]`, значения — в `ma_values` (или вместе, если оптимизация не используется).

Хеш-таблица использует открытое хеширование с пробингом и хранит хеши ключей. При росте она расширяется с перераспределением элементов. Объект содержит указатель на таблицу, счётчики и параметры перераспределения. Пустой словарь занимает около **240 байт**. Ключи должны быть хешируемыми и неизменяемыми.

```
+---------------------------------+
| PyDictObject                    |
+---------------------------------+
| ob_refcnt                   8 B |
| tp_type                     8 B |
| padding и другие поля     200 B |
| ma_used                     8 B |  количество элементов
| ma_keys                     8 B |  указатель на PyDictKeysObject
| ma_values                   8 B |  указатель на ma_values[]
+---------------------------------+

+---------------------------------+
| PyDictKeysObject                |
+---------------------------------+
| dk_size                     8 B |  размер таблицы
| dk_nentries                 8 B |  число занятых ячеек
| dk_indices[]                N   |  хеш-таблица
| entries[]              N * 16 B |  массив структур: hash, key
+---------------------------------+

+---------------------------------+
| ma_values[]                     |
|---------------------------------|
| value0 (ссылка на obj0)     8 B |
| value1 (ссылка на obj1)     8 B |
| ...                             |
+---------------------------------+
```


## Сборка мусора

Конструкция `del` удаляет **имя**, а не сам объект. Объект остаётся в памяти, пока на него существуют другие ссылки. Перед удалением объекта вызывается (если определен) его метод `__del__()` для освобождения внешних ресурсов. После этого освобождается занимаемая объектом память.

Python очищает память с помощью двух механизмов: немедленное освобождение при снижении **счётчика ссылок** (*reference counting*) на объект до нуля; и дополнительная сборка мусора через **циклический сборщик мусора** (*garbage collector*) `gc` при возникновении циклических ссылок.

Модуль `gc` работает по **поколенческой модели**: объекты делятся на поколения (`0` — новые объекты, `1` — выжившие после первой сборки, `2` — долго живущие объекты). Чем дольше объект живёт, тем реже проверяется. Доступно ручное управление:

`gc.collect()` — запускает сборку мусора вручную

`gc.get_count()` — возвращает количество объектов в каждом поколении

`gc.disable()` / `gc.enable()` — отключение и включение сборщика

`gc.set_debug()` — включает отладочную информацию.

Простые типы (`int`, `str`, `float`, `tuple`, `frozenset`) считаются неподверженными циклам и не участвуют в сборке мусора. Отслеживаются списки, словари, пользовательские объекты и замыкания.

Модуль `weakref`, позволяет создавать слабые ссылки — они не увеличивают счётчик ссылок (не создают циклические ссылки) и не препятствуют удалению объекта. Если объект удаляется, то слабые ссылки на него становятся `None`


## Области видимости

Все объекты относятся к какой-то **области видимости** (*scope*). Место определения объекта в коде связывает его с пространством имен (*namespace*) и определяет его область видимости. Облась видимости помогает предотвратить конфликты имен (*prevent name clashes*). В Python используется **лексическая область видимости** (*lexical scoping*), которая включает: локальную (*local*) — внутри функции,  нелокальную (*nonlocal*) — в объемлющих функциях (от внутренней к наружной), глобальная (*global*) — за пределами всех функций, встроенная (*built-in*) — в модуле `builtins`. Таким образом лексическая область видимости реализована через правило **LEGB** (`Local`, `Enclosing`, `Global`, `Built-in`) и содержит 4 уровня, через которые проходит интерпретатор при поиске объекта.

Операторы `global` и `nonlocal` модифицируют правила привязки к пространству имен:
**`global`** — определяет переменную на уровне модуля, при этом поиск переменной начинается с области видимости модуля, затем переходит к объемлющей области видимости.
**`nonlocal`** — изменяет существующую переменную на уровне объемлющей функции (*enclosing function*), но ее поиск происходит только в объемлющей области.

Формально есть три дополнительные области видимости (*special-case scopes*): временные переменные циклов включений (локальны в генераторных выражениях и включениях), переменные ссылок на исключения в некоторых обработчиках try (локальны внутри `except` и уничтожаются при выходе из него) и локальные области видимости в классах (подпадают под действие `LEGB`).

Существует так же **динамическая область видимости** (*dynamic scope*), в которой область действия переменной определяется цепочкой вызовов во время выполнения. Она используется в некоторых языках, например, старых версиях `Lisp`.



## Импорт

**Файл верхнего уровня** (*top-level script*) содержит **основной поток управления** (*main flow*) программы и может использовать другие файлы в виде модулей. Модуль — это **изолированное пространство имён** (*namespace*), где все верхнеуровневые переменные становятся атрибутами объекта модуля при импортировании (глобальная область видимости модуля становится пространством имен его объекта). 

**Импорт** — это механизм, с помощью которого загружается внешний код в текущую программу. Это не только подгрузка файла, но и создание объектов модулей, управление пространством имён, кэширование. Импортироваться могут не только `.py`-файлы, но и `.pyc`, расширения на `C`, архивы и `namespace`-пакеты.

При импорте Python проверяет, есть ли модуль в кэше `sys.modules`. Если нет — ищет его и компилирует в байткод. Создаёт объект модуля `ModuleType` и добавляет его в `sys.modules`. Выполняет код модуля. Связывает модуль с именем в текущем пространстве имён.

Поиск модуля происходит в директориях, перечисленных в списке `sys.path`, в следующем порядке: текущая директория (или каталог скрипта верхнего уровня), каталоги, добавленные через переменную среды `PYTHONPATH`, каталоги стандартной библиотеки, а также директории установленных пакетов, такие как `site-packages`.

`PYTHONPATH` — это переменная окружения, с помощью которой можно добавить директории в путь поиска модулей `sys.path`. При запуске интерпретатор считывает её значение, разбивает по разделителю и добавляет полученные пути в начало списка `sys.path`, сразу после текущей директории. `sys.path` можно динамически изменять в процессе выполнения кода с помощью `append` или `insert`.

- **`import`** — загрузить модуль целиком и связать с именем в текущем пространстве имен. Становятся доступны все внутренние имена из импортируемого модуля.
- **`from`** — импортировать отдельные имена из модуля. Модуль выполняется, но имя модуля не создаётся. `from ... import *` копирует все публичные имена в текущую область (имена с префиксом `_` исключаются). Но доступны становятся только те имена, которые уже были определены на момент импорта.
- **`as`** — задаёт короткий синоним (*short synonym*) модулю в текущей области видимости для устранения конфликтов имен (*name clashes*).
- **`reload`** — повторно выполняет код модуля, обновляя его на месте. Работает только для модулей на Python и не перезагружает вложенные импорты.

Операторы `import` и `from` являются исполняемыми выражениями (*executable statements*), поэтому могут использоваться внутри функций и условных конструкций. Фактически они выполняют неявное присваивание (*implicit assignment*). При импорте модуля выполняется его верхнеуровневый код — поэтому, если модуль содержит действия при загрузке, они будут выполнены и при его импорте. Однако код внутри функций исполняется только при их вызове, поэтому функции могут содержать ссылки на объекты, которые будут определены позже (*forward references*).

**Модуль** — это обычный `.py`-файл, содержащий Python-код. Если два модуля импортируют друг друга, возникает циклический импорт (*circular import*). Чтобы избежать его следует выносить общие зависимости в третий модуль или использовать `import` внутри функций (отложенный импорт).

**Пакет** (*package*) — это каталог с Python-кодом, который при импортировании превращается в объект пространства имён с атрибутами, соответствующими вложенным подкаталогам и модулям. Импорт пакета включает запуск его `__init__.py` (*initialization hook*). После импорта путь `import` становится цепочкой вложенных объектов (*nested object path*). Внутри пакета по умолчанию используется **абсолютный импорт** (*absolute import*), который ищет модули через `sys.path`, минуя текущий каталог. Для доступа к соседним модулям используется **относительный импорт** (*relative import*), где точка (`.`) указывает на текущий пакет, а двойная точка (`..`) — на родительский. Поиск при этом ограничен структурой пакета, и внутренние модули могут перекрывать внешние с тем же именем (стандартные остаются доступными).

**Пакет пространства имён** (*namespace package*) — это каталог без файла `__init__.py`. Такие пакеты позволяют объединять модули из нескольких мест. Они содержат атрибут `__path__` (список путей), используемый для поиска вложенных модулей (аналог `sys.path`, но локальный).


## Функции

**Функции** — это инструмент разбиения систем на части (`procedural decomposition`). Предназначены для максимального переиспользования кода (*maximizing code reuse*) и сведения к минимуму избыточности (*minimizing redundancy*). Функции должны иметь единственное предназначение и не должны иметь побочных эффектов. Они должны работать изолированно и не должны изменять объекты во внешних областях видимости. По соглашению функция, изменяющая объект на месте, должна возвращать `None`, давая понять, что изменился сам объект.

В Python функции — это объекты первого класса (экземпляры класса `function`). Их можно сохранять в переменные, передавать как аргументы, возвращать из других функций и создавать динамически (через `exec`, `eval` или `types.FunctionType`). Функции определяются с помощью ключевого слова `def` или выражения `lambda` (создаются внутри выражений и могут содержать только выражения). Создание функции не вызывает её, интерпретатор просто создаёт объект `PyFunctionObject`, который в числе прочих атрибутов содержит ссылку на ее объект кода (метаданные и тело функции, скомпилированные в байткод). Список всех встроенных функций хранится в словаре `__builtins__.dict`.

**`def`** — конструкция, которая создает объект функции (функции не существует, пока до нее не дойдет поток выполнения)
**`lambda`** — анонимная функция (*anonymous function*), которая создает объект функции и возвращает его не присваивая имени

**Функции высшего порядка** (*higher-order functions*) — это функции, которые принимают другие функции в качестве аргументов или возвращают их как результат: `map`, `filter`, `reduce`, `sorted`, `min`, `max`.

**Замыкания** (*closure*) — это функции, которые сохраняют ссылки на переменные из внешней области видимости (*enclosing scope*), даже после завершения этой области. (локальные переменные не будут уничтожены пока на них остаются ссылки). Такие переменные называются **свободными** (*free variables*). В Python их имена хранятся в `__code__.co_freevars`, а значения — в `__closure__`, что позволяет функции обращаться к ним позже.

```python
def f1():
   x = 2
   def f2():
       print(x)
   return f2

action = f1()
action()  # 2
```

При определении функции её тело компилируется в **объект кода** (*code object*). Один объект кода может использоваться разными функциями — это позволяет реализовывать замыкания, декораторы и генерацию функций во время выполнения. Поскольку функции являются объектами, к ним можно присоединять атрибуты, которые способны сохранять состояние между вызовами функций (доступ к ним возможен как изнутри, так и снаружи).

Аргументы функций передаются по **вызову по соиспользованию** (*call by sharing*): функция получает копию ссылки на переданный объект. Изменяемые аргументы можно модифицировать внутри функции, но нельзя заменить на другие. Поэтому изменяемые значения нельзя использовать в качестве значений по умолчанию — они будут общими для всех вызовов.

При создании функций следует придерживаться **принципа наименьшего удивления** (*principle of least astonishment*): если назначение элемента неочевидно, его поведение должно быть максимально предсказуемым для пользователя.

**Функциональное программирование** (*functional programming*) позволяет применять функции к итерируемым объектам:

**`map`** — вызов функции на элементах итерируемого объекта
**`filter`** — фильтрация элементов на основе проверяемой функции
**`functools.reduce`** — применение функции к парам элементов и результатов выполнения

Существует целый ряд **вызываемых объектов** (*callable object*), которые позволяют использовать оператор вызова `( )`. Это функции, методы, классы, экземпляры классов, генераторные функции. Кроме того, с помощью метода __call__ можно любой объект сделать вызываемым.


## Рекурсия

**Рекурсивная функция** (*recursive function*) вызывает саму себя в своем теле или через другую функцию (*indirect recursion* — косвенная рекурсия). Рекурсивная функция должна содержать:

- **`Базовый случай`** с необходимым условием остановки . 
- **`Рекурсивный случай`** (шаг рекурсии) с условием продолжения.

Например, вычисление факториала:

```python
>>> def f(n):
       return 1 if n == 0 else n * fac(n - 1)
```


## Декораторы

**Декораторы** (*decorators*) — это вызываемые объекты (функции или классы), которые принимают и возвращают другие вызываемые объекты, добавляя к ним дополнительную логику. Они обеспечивают явный синтаксис (*explicit syntax*), способствуют инкапсуляции (*encapsulation*), повышают согласованность (*consistency*) и облегчают сопровождение кода (*code maintenance*). Однако декораторы могут изменять исходный тип (*type changes*) и вносят издержки на дополнительный вызов (*extra calls*). Выполняется декоратор сразу после определения функции, но до её первого вызова. Он применяются при загрузке модуля, но сами декорируемые функции выполняются только при явном вызове. При вложении декораторов порядок их выполнения будет обратный.

Декоратор состоит из символа `@` и ссылки на метафункцию (*metafunction*); декорирование означает повторную привязку (*rebind*) функции к этой метафункции. При вызове функции сначала вызывается метафункция. Если декоратор — функция, состояние сохраняется в объемлющей области видимости; если класс — в его атрибутах.

```python
def decorator(callback):
    def wrapper(*args):
        callback(*args)
    return wrapper

@decorator
def spam(a):
    return a
```

**Декораторы классов** (*interface proxies* — посредники интерфейсов) применяются для управления всем классом или дополнения интерфейсов его экземпляров. Обычно реализуются как обёртки, которые создают прокси-объекты и перенаправляют доступ к атрибутам через `__getattr__`:

```python
def decorator(cls):
    class Proxy:
        def __init__(self, *args):
            self.wrapped = cls(*args)
        def __getattr__(self, name):
            return getattr(self.wrapped, name)
    return Proxy

@decorator
class Spam:
    pass
```

**Декораторы функций** (*call proxies* — посредники вызовов) используются для управления вызовами функций и их поведением. Обычно реализуются через класс или функцию, сохраняющую ссылку на оригинальную функцию и перехватывающую вызовы:

```python
class tracer:
    def __init__(self, func):
        self.calls = 0
        self.func = func
    def __call__(self, *args):
        self.calls += 1
        return self.func(*args)

@tracer
def spam(a, b):
    return a + b
```

**Параметризованные декораторы** выглядят так, будто принимают аргументы, хотя на деле эти аргументы сохраняются во внешней функции, которая возвращает фактический декоратор. Такая структура включает три уровня: внешний уровень — конфигурация, средний — сам декоратор, внутренний — обёртка или вызываемый объект:

```python
def repeat(times):  # Внешняя функция получает аргумент
    def decorator(func):  # Декоратор получает функцию
        def wrapper(*args, **kwargs):  # Обёртка вызывает функцию
            result = None
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hello!")
```

**Встроенные декораторы** (*built-in decorators*):

**`@property`** — превращает метод в атрибут, доступный только для чтения.
**`@staticmethod`** — объявляет метод, не получающий `self` или `cls`; работает как обычная функция внутри класса.
@**`classmethod`** — передаёт в метод класс (`cls`) вместо экземпляра (`self`); используется, например, для альтернативных конструкторов.
**`@functools.wraps`** — сохраняет метаданные (например, `__name__`, `__doc__`) оригинальной функции при декорировании.
**`@lru_cache`** (из `functools`) — кеширует результаты вызова функции с теми же аргументами, ускоряя повторные вычисления.


## Парсинг

На начальном этапе выполнения программы Python разбирает исходный код на **токены** (*lexical analysis* — лексический анализ), из которых затем строится **синтаксическое дерево** (*parse tree* — дерево разбора), отражающее полную структуру кода. Затем синтаксическое дерево преобразуется в более компактное **абстрактное синтаксическое дерево** (*AST*, *abstract syntax tree*).

`AST` — это иерархическая структура, где каждый узел соответствует конструкции языка: присваиванию, вызову функции, арифметической операции и т.д. Например, выражение `x = a + 1` будет представлено как узел `Assign`, в котором есть `Name(id='x')` и `BinOp(left=Name(id='a'), op=Add(), right=Constant(1))`.

Для парсинга используется модуль `ast`, который позволяет: анализировать код как структуру дерева, модифицировать узлы дерева, создавать Python-код программно. Например:

```python
import ast

tree = ast.parse("x = a + 1")
print(ast.dump(tree, indent=2))
```

Результат:
```
Module(
  body=[
    Assign(
      targets=[Name(id='x', ctx=Store())],
      value=BinOp(
        left=Name(id='a', ctx=Load()),
        op=Add(),
        right=Constant(value=1)
      )
    )
  ],
  type_ignores=[]
)
```

## Компиляция

CPython не поддерживает динамическую компиляцию (*just-in-time* — *JIT*) или компиляцию перед исполнением (*ahead-of-time* — *AOT*). Вместо этого происходит компиляция `AST` в **байткод** (*bytecode*) — промежуточное представление, понятное интерпретатору. Байткод хранится в объекте типа `code` (`PyCodeObject`) и состоит из последовательности инструкций, аналогичных ассемблеру виртуальной машины Python. Для преобразования AST в байткод используется функция `compile()`:

```python
code = compile("x = a + 1", filename="<string>", mode="exec")
print(code.co_code)  # байткод
```

Результат:
```
b'\x97\x00e\x00d\x00z\x00\x00\x00Z\x01y\x01'
```

Байткод — это последовательность инструкций, которую понимает виртуальная машина CPython. Он хранится в виде строки байтов и лежит внутри объекта кода в поле `co_code`. Байткод не зависит от платформы и версий ОС, но зависит от версии Python. Он не исполняется напрямую системой, а интерпретируется виртуальной машиной CPython.


## Объект кода

Объект кода (*code object*) `PyCodeObject` содержит всю скомпилированную информацию, необходимую для выполнения фрагмента программы — функции, модуля или выражения. Он создаётся автоматически при компиляции и является неизменяемым. Объект кода можно исследовать для анализа, отладки или оптимизации. Он включает:

- **`co_code`** — последовательность байт (байткод), которую исполняет виртуальная машина CPython.
- **`co_consts`** — кортеж всех констант, использованных в коде: числа, строки, `None`, вложенные объекты кода.
- **`co_names`** — кортеж имён глобальных переменных, функций и атрибутов, к которым происходит обращение.
- **`co_varnames`** — кортеж имён локальных переменных, включая аргументы функции.
- **`co_cellvars`** — переменные, замкнутые во вложенных функциях (используются в замыканиях).
- **`co_freevars`** — переменные, полученные из внешней области видимости (для замыканий).
- **`co_argcount`** — количество обычных позиционных аргументов.
- **`co_posonlyargcount`** — количество только позиционных аргументов (используются с `/`).
- **`co_kwonlyargcount`** — количество только именованных аргументов (используются с `*`).
- **`co_nlocals`** — общее число локальных переменных (включает аргументы).
- **`co_stacksize`** — максимальный размер стека, необходимого для выполнения.
- **`co_flags`** — битовая маска, описывающая свойства кода (например, использует ли `*args`, `**kwargs`, является ли генератором и т.д.).
- **`co_filename`** — имя файла, из которого получен исходный код.
- **`co_name`** — имя блока, например имя функции или `'module'` для верхнего уровня.
- **`co_firstlineno`** — номер первой строки исходного кода.
- **`co_linetable`** (или `co_lnotab` в старых версиях) — таблица соответствия между байткодом и строками исходного кода (для отладки и трассировки).

Пример:

```python
def f(x): return x + 1

print(f.__code__.co_code)       # байткод
print(f.__code__.co_varnames)   # ('x',)
print(f.__code__.co_consts)     # (None, 1)
```

## Кэширование

При импорте модуля Python автоматически компилирует `.py` в байткод и сохраняет его в файл `.pyc` (compiled py) в каталоге `__pycache__` (при наличии прав на запись). Изменение исходного кода или использование другой версии Python инициирует перекомпиляцию. Байткод не сохраняется для файлов верхнего уровня.

`.pyc`-файлы — это сериализованные объекты кода, содержащие байткод и метаинформацию (время модификации `.py` и магическое число версии). Они читаются быстрее, чем исходный код, но не защищены от декомпиляции.

Имя `.pyc`-файла содержит версию интерпретатора:

```bash
__pycache__/example.cpython-311.pyc
```

Этот файл можно скомпилировать явно:

```bash
python -m compileall my_module.py
```

Или программно:

```python
import py_compile
py_compile.compile('my_module.py')
```


## Выполнение

Скомпилированный объект кода передаётся виртуальной машине CPython (*Python Virtual Machine*, *PVM*) — центральному компоненту интерпретатора, который выполняет байткод. `PVM` реализован на `C` и управляется функцией `eval_frame()`, лежащей в основе исполнения любой инструкции. Эта функция запускает цикл интерпретации (*interpreter loop*), в котором поочерёдно считываются и выполняются команды байткода.

Для исполнения каждого фрагмента кода (модуля, функции или выражения) `PVM` создаёт отдельный объект фрейма (*frame object*) `PyFrameObject`, который содержит: указатель текущей инструкции, локальные и глобальные переменные, стек операндов, ссылку на вызывающий фрейм. При вызове нового фрагмента кода создаётся новый фрейм, который помещается в стек вызовов (*call stack*). Когда выполнение этого фрагмента завершается, его фрейм удаляется, и управление возвращается к предыдущему. Так поток выполнения образует цепочку вызовов (*call chain*).

При исполнении инструкции байткода `PVM` по `opcode` определяет нужную операцию и вызывает соответствующую реализацию на `C`, которая выполняет операцию и обновляет стек операндов (*operand stack*). В этом стеке хранятся промежуточные аргументы и через него происходит их передача между инструкциями. Функции `C` реализуют все базовые операции языка — арифметику, вызов функций, создание объектов и др.

Python `3.6` и новее использует двухбайтные инструкции: `opcode` и аргумент `oparg`. Если у инструкции нет аргумента, второй байт заполняется нулём:

```
 0  LOAD_CONST    1 (1)     # загрузить константу 1 на стек
 2  LOAD_CONST    2 (2)     # загрузить константу 2 на стек
 4  BINARY_ADD              # сложить два верхних значения стека
 6  STORE_FAST    0 (x)     # сохранить результат в локальную переменную x
 8  LOAD_CONST    0 (None)  # загрузить константу None (для return)
10  RETURN_VALUE            # вернуть значение (None)
```

В Python `3.11` перешли на новую байткод-схему: инструкции начинаются с одного байта `opcode`, но аргумент `oparg`, если он есть, может занимать два байта (16 бит). Если значение аргумента превышает этот диапазон, используется специальная инструкция `EXTENDED_ARG`, расширяющая размер аргумента до 24, 32 и более бит. В результате длина инструкции может превышать два байта.

Выполнение происходит автоматически при запуске `.py`-файла, при импорте модуля, при вызове функции, уже скомпилированной в объект кода. Можно вручную выполнить объект кода с помощью `exec()`:

```python
code = compile("x = 2 + 2", "<string>", "exec")
exec(code)
print(x)  # 4
```


## Отладка

Отладка реализована через **хуки трассировки** (*trace hooks*), которые используются отладчиками для перехвата управления. Интерпретатор дает возможность установки **функции трассировки** (*trace function*) через `sys.settrace()`. Когда отладчик запускается или встречает `pdb.set_trace()`, он вызывает `sys.settrace()`, передавая ему свою собственную функцию обратного вызова (*callback function*) `trace_function`, которая будет вызываться интерпретатором при каждом значимом событии (`call`, `line`, `exception` и др.) во время исполнения кода. `trace_function` вызывается с тремя аргументами: `frame` (текущий фрейм), `event` (тип произошедшего события), `arg` (зависит от типа события).

При вызове `trace_function` отладчик анализирует `frame` и `event` и если отладчик находится в режиме пошагового выполнения и событие соответствует точке останова (событие `line` и текущий файл и номер строки совпадают с одной из точек останова), он приостанавливает выполнение программы. Затем отладчик предоставляет пользователю интерфейс, позволяющий просматривать переменные и стек вызовов, и управлять потоком выполнения:

- **`step over`** — отладчик временно отключает трассировку для всех вложенных вызовов, пока не вернется на тот же уровень стека, что и текущий, или не дойдёт до следующей строки.
- **`step into`** — отладчик не отключает трассировку, позволяя ей войти во вложенный вызов функции и остановиться на первой строке этой функции.
- **`continue`** — отладчик временно отключает `trace_function` или игнорирует события пока не будет достигнута следующая активная точка останова, или пока программа не завершится.


## Профайлинг

В CPython есть встроенный профайлер `cProfile`, который написан на `C`. Принципы работы профайлера очень схожи с работой отладчика, но вместо остановки выполнения профайлер собирает статистику времени выполнения и количестве вызовов функций.
 
Как и отладчик, профайлер использует функцию `sys.setprofile(profile_function)`. Функция `profile_function` также вызывается интерпретатором при каждом "значимом" событии во время выполнения кода: `call` (профайлер начинает отсчет времени для этой функции), `return` (профайлер останавливает отсчет времени для этой функции и записывает время), `exception` (произошло исключение). Все данные профайлер записывает с привязкой к конкретному фрейму и хранит их в памяти в специальной структуре данных.

Профайлеры различают два вида времени: **общее время** (*total time*), проведенное в функции, включая время, затраченное на вызовы всех функций, которые она сама вызывает и  **собственное время** (*cumulative time*), проведенное в самой функции, исключая время, на вызовы других функций.

После завершения профилирования собранные данные можно представить в удобочитаемом формате. Модуль `pstats` (часть стандартной библиотеки) используется для обработки и сортировки данных, собранных cProfile или profile, и вывода их в консоль или сохранения в файл.
 
cProfile можно запустить из командной строки (для целого скрипта):
 
```bash
python -m cProfile -o output.prof your_script.py -o output.prof
```

Внутри кода (для конкретных блоков или функций):

```python
import cProfile
import pstats
 
def my_function_to_profile():
    total = 0
    for i in range(1000000):
        total += i
    return total

if name == "main":
    profiler = cProfile.Profile()
    profiler.enable() # Начать профилирование

result = my_function_to_profile() # Код, который мы хотим профилировать
 
    profiler.disable() # Завершить профилирование

    # Получить статистику и вывести ее
    stats = pstats.Stats(profiler)
    stats.strip_dirs()  # Убрать пути к файлам для более чистого вывода
    stats.sort_stats('cumulative') # Сортировать по кумулятивному времени
    stats.print_stats(10) # Вывести топ-10 строк
    # stats.dump_stats("my_profile_data.prof") # Сохранить в файл
```

Анализ файла .prof с помощью `pstats`:
 
```python
import pstats

# Загрузить данные из файла
stats = pstats.Stats("output.prof")

stats.strip_dirs()
stats.sort_stats('time') # Сортировать по общему времени, проведенному в функции
stats.print_stats() # Вывести всю статистику
```


## Исключения

**Исключения** — это механизм управления потоком выполнения (*control flow*), который позволяет немедленно завершить все активные вызовы функций и перейти к обработчику исключений (*exception handler*). Но при этом сохраняется текущий контекст, чтобы после обработки исключения управление могло вернуться к нему. Если исключение обработано, выполнение продолжается после `try`; если нет — срабатывает стандартная обработка: сообщение об ошибке, остановка программы и очистка памяти. Все исключения наследуются от `BaseException`, пользовательские — от `Exception`.

**`try`**/**`except`** — перехватывает исключение и производит восстановление после него. Можно указывать несколько типов или оставить `except`. По завершении блока `except` все переменные из него удаляются.
**`else`** — выполняется, если исключений не возникло.
**`finally`** — выполняется всегда: и при обычном завершении, и при возникновении исключения. Если исключение не обработано, после finally оно передаётся дальше — встроенному или внешнему обработчику. Блок `finally` срабатывает даже если ошибка произошла внутри except.
**`raise`** — инициирует исключение или повторно выбрасывает текущее (если без аргументов).
**`assert`** — генерирует `AssertionError`, используется для проверок условий.
**`sys.exc_info`** — предоставляет доступ к самому последнему исключению.

Если в блоке `except` возникает новое исключение, то предыдущее исключение автоматически сохраняется в атрибуте `__context__` нового. Так строится цепочка исключений.

Если нужно принудительно связать одно исключение с другим, можно использовать `raise ... from ...`. В этом случае новое исключение будет хранить старое в атрибуте `__cause__`, и Python выведет оба (чтобы подавить такое сцепление, можно использовать `raise ... from None`):

```python
try:
    1 / 0
except Exception as e:
    raise TypeError from e
```


## Классы и объекты

Классы и объекты в Python — это пространства имён: атрибуты класса общие для всех экземпляров, если не переопределены. Классы объединяют данные и поведение, обеспечивая повторное использование кода.

**Классы** — это фабрики объектов: они создают экземпляры и определяют поведение, общее для всех их экземпляров. Классы можно вкладывать друг в друга, создавая иерархии. Атрибуты класса становятся частью интерфейса объектов и наследуются ими.

Сами классы тоже являются объектами и создаются с помощью **метаклассов**. По умолчанию метаклассом является `type`, то есть каждый класс является экземпляром `type`. При этом `type` — это одновременно и класс, и тип всех классов. Иначе говоря, типом любого объекта является его класс, а типом любого класса — `type`.

Модель завершается тем, что `type` унаследован от `object`, а `object` — экземпляр `type`. Это образует циклическую, но непротиворечивую структуру: `object` — это базовый класс, от которого наследуются все остальные классы (включая `type`), а `type` — это метакласс, который создаёт `object`. Именно через `object` реализуется фундаментальное поведение всех объектов. Он определяет базовый набор стандартных атрибутов и методов, который наследуется каждым объектом и классом.

Можно создавать подклассы от встроенных типов, таких как `list`, `dict` или `str`, но такие подклассы могут вести себя непредсказуемо, поскольку многие методы этих типов реализованы на `C` и не учитывают переопределения в подклассах. Поэтому вместо них часто используют адаптированные классы из модуля `collections`, такие как `UserDict` или `UserList`. 

**`class`** — это исполняемый оператор, который создаёт объект класса и сохраняет на него ссылку в указанном имени. Класс не существует пока интерпретатор не выполнит оператор `class`.

Тело класса выполняется как обычный код в отдельной локальной области видимости. Все присваивания на верхнем уровне внутри тела класса становятся атрибутами создаваемого объекта класса. Эта область затем превращается в пространство имён класса.

Класс может обращаться к объемлющим областям видимости, но сам не становится такой областью для вложенных функций и выражений. То есть, при поиске имён вложенный код не видит переменные, определённые на верхнем уровне класса напрямую — к ним нужно обращаться как к атрибутам класса или экземпляра.

При каждом обращении к объекту класса создаётся новый экземпляр с собственным пространством имён. Это пространство имеет доступ к атрибутам класса. По сути, любой объект — это пространство имён, связанное со своим классом, откуда он наследует поведение.

Методы определяются на уровне класса и не принадлежат конкретному объекту, поэтому в методы экземпляра явно передаётся параметр `self`, указывающий на сам объект. Внутри класса могут быть: **методы экземпляра** (принимают `self`), **методы класса** (принимают `cls`), **статические методы** (не принимают ни `self`, ни `cls`). Для создания двух последних методов используются декораторы `staticmethod` и `classmethod`.

**`cls.__bases__`** — содержит кортеж базовых классов.
**`cls.__qualname__`** — хранит полное квалифицированное имя класса (или функции), включая вложенность.
**`cls.__subclasses__()`** — возвращает список всех непосредственных подклассов.
**`cls.mro()`** — используется при построении класса для вычисления порядка разрешения методов (MRO) и возвращает кортеж суперклассов; его результат сохраняется в атрибуте `__mro__`.

**Объекты** (*instances* — экземпляры) — это конкретные сущности, чьи атрибуты содержат индивидуальные данные. Они наследуют поведение и общие свойства от своего класса, а класс — от родительских классов выше по иерархии.

**Инкапсуляция** (*encapsulation*) означает, что логика и данные объединяются внутри объекта через его интерфейс, что помогает избегать повторения кода (*redundancy*). В Python нет строгого механизма скрытия данных — это достигается лишь по соглашению. Каждый объект имеет своё пространство имён, а сложные объекты могут включать другие объекты внутрь себя — такую структуру называют композицией (*composition*).

**Наследование** (*inheritance*) — это механизм, при котором подклассы (*subclasses*) получают атрибуты и поведение своих родительских классов (*superclasses*) и могут переопределять (*override*) их при необходимости. Объекты, в свою очередь, наследуют поведение от своего класса. Изменение унаследованного атрибута называется перегрузкой (*overloading*).

**Полиморфизм** (*polymorphism*) — это способность операций вести себя по-разному в зависимости от объекта. Он основан на абстракции: важен не тип, а интерфейс. Код должен опираться на поведение объекта, а не на его класс, чтобы работать с разными типами, включая будущие.

**super()** позволяет обобщённо обращаться к суперклассу в соответствии с `MRO`. Однако при множественном наследовании поведение `super()` может быть неочевидным, поэтому чаще рекомендуется вызывать методы суперклассов напрямую. Использование `super()` оправдано в случаях, когда иерархия классов формируется динамически.


### Проектирование классов

**Семантические отношения между классами** описывают, какая логическая связь существует между ними. Эти отношения помогают правильно моделировать предметную область и выбрать подходящий способ связи между классами. Они определяют смысл, но не диктуют реализацию:

**Наследование** (`is-a`) означает, что один класс является разновидностью другого. Это отношение используется, когда подкласс логически соответствует суперклассу и может быть использован вместо него без изменения смысла. Например, `Кошка` — это `Животное`. Наследование следует применять только при наличии отношения подтипа, а не ради повторного использования кода.

**Композиция** (`has-a`) описывает отношение, при котором один объект состоит из другого и управляет его жизненным циклом. Например, `Автомобиль` содержит `Двигатель`. Композиция предпочтительнее наследования, если классы не находятся в иерархии подтипов, а просто взаимодействуют как части целого.

**Агрегация** — это ослабленная форма композиции. Один объект использует другой, но не владеет им. Например, `Класс` может агрегировать `Студентов`, однако студенты существуют независимо от класса. Агрегация используется, когда объекты связаны, но не зависят друг от друга по времени жизни.

**Ассоциация** — самое слабое отношение: объекты просто знают друг о друге и могут взаимодействовать. Например, `Врач` может быть связан с `Пациентом`, но оба существуют независимо. Ассоциации не предполагают владения или подчинённости и используются при необходимости связать объекты без тесной зависимости.

**Механизмы комбинирования классов** описывают, как реализовать отношения между классами в коде. Они про структуру и поведение на уровне реализации. Механизмы выбираются в зависимости от целей (переиспользование кода, расширяемость, снижение связности и др.):

**Наследование** — класс явно унаследован от другого и получает его поведение. Используется при логическом подтипе.

**Композиция** — класс содержит другие объекты как поля и вызывает их методы. Объекты встроены напрямую.

**Делегирование** — класс передаёт выполнение некоторых своих методов другому объекту, к которому имеет доступ. (вручную или через __getattr__). Позволяет оборачивать или расширять поведение.

**Миксины** — механизм множественного наследования, где примеси добавляют функции к основному классу без логической связи "является".

**Комбинированные шаблоны** — можно использовать и наследование, и делегирование одновременно, например: один суперкласс и множество примесей.


## `MRO`

Если при множественном наследовании в ромбовидной схеме у суперклассов есть методы с одинаковыми именами, возникает проблема ромбовидного наследования (`diamond problem`) — возникает неоднозначность, какой метод должен быть вызван. Неоднозначность разрешается с помощью **MRO** — (*method resolution order*). Он нужен для того, чтобы Python однозначно и безопасно выбирал метод при множественном наследовании. Алгоритм гарантирует, что один и тот же класс не появляется в цепочке дважды, и порядок всегда стабилен.

Метод `mro()` возвращает кортеж (содержимое `__mro__`), который задает порядок поиска в иерархии включая все классы от текущего до корневого `object`, каждый класс находится перед своими родителями (родители сохраняют порядок из `__bases__`).

Алгоритм MRO использует `C3`-линеаризацию, которая подчиняется таким правилам:
1. Обход иерархии классов происходит в порядке **DFLR** (*depth-first left-to-right*), то есть от текущего класса к базовым: сначала обходится левый базовый класс и все его предки, затем правый и его предки.
2. При построении итоговой последовательности все дубликаты удаляются, и каждый класс включается только один раз — в месте своего первого допустимого появления.
3. Порядок следования базовых классов остаётся таким, как задан в определении класса.

Для избежания проблем с `MRO` рекомендуется использовать обычное наследование только при наличии отношения "является"; в остальных случаях предпочтительнее композиция. Интерфейсы следует задавать через абстрактные базовые классы `ABC`, а общую функциональность — через миксины. В множественном наследовании конкретным должен быть только один суперкласс, остальные — примеси или абстрактные классы.

**Миксин (mixin)** — это вспомогательный класс, предназначенный для добавления функциональности другим классам через множественное наследование. Миксины **не используются самостоятельно**, они не предполагают создание экземпляров и обычно не имеют собственного состояния. Основное назначение миксинов — **расширять поведение** основного класса, не нарушая принцип единственной ответственности. В иерархии наследования миксины, как правило, размещают **слева от базового класса**, чтобы их методы имели приоритет в `MRO`. По соглашению, имена миксинов обычно заканчиваются на `Mixin`.


## Атрибуты

Все атрибуты экземпляра по умолчанию хранятся в `__dict__`, что позволяет динамически добавлять поля объекту. Чтобы ограничить допустимые атрибуты и сэкономить память, используется `__slots__` — специальный атрибут класса, задающий фиксированный список допустимых полей и отключающий создание `__dict__`. При обращении к атрибуту Python сначала ищет его в `__dict__` экземпляра, затем в классе и далее по иерархии наследования в порядке, заданном `__mro__` (*method resolution order*).

**Псевдозакрытые атрибуты** (*pseudoprivate*) начинаются с двойного подчеркивания (но не заканчиваются им): `__attr`. Они предназначены для избежания случайного переопределения в подклассах и автоматически расширяются, чтобы содержать впереди имя класса с одиночным подчеркиванием: `_Class__attr`. Это называется **декорирование имён** (*name mangling*). Поскольку добавлять атрибуты к экземпляру могут сразу несколько классов, корректировка имен предохраняет от случайного переопределения атрибутов ниже в иерархии наследования. Атрибуты с одним подчёркиванием в начале не обрабатываются особым образом, но по соглашению считаются внутренними.

Встроенные функции для работы с атрибутами:

**`getattr(obj, name, default)`** — возвращает значение атрибута с именем `name` у объекта `obj`, при отсутствии — либо возвращает `default`, либо возбуждает `AttributeError`.
**`hasattr(obj, name)`** — возвращает `True`, если у объекта есть указанный атрибут (в том числе унаследованный)
**`setattr(obj, name, value)`** — возвращает `__dict__`, но не работает с объектами, у которых определён `__slots__` без `__dict__`. Без аргумента `vars()` возвращает локальные переменные текущей области видимости (аналогично функции `locals()`).

Специальные методы для работы с атрибутами ищутся в классе, даже если вызываются от имени экземпляра:

**`__getattribute__(self, name)`** — вызывается всегда при доступе к атрибуту (кроме случаев, когда атрибут является специальным атрибутом или методом). К вызову этого метода приводит уточнение атрибута через нотацию с точкой и вызов встроенных функций `getattr()` и `hasattr()`. Если вызов привел к исключению `AttributeError`, то вызывается `__getattr__()`. Чтобы избежать бесконечной рекурсии следует использовать `super().__getattribute__(name)` внутри этого метода.
**`__getattr__(self, name)`** — вызывается только если атрибут не найден в экземпляре, классе или суперклассах. Используется как «резервный» обработчик отсутствующих атрибутов.
**`__setattr__(self, name, value)`** — вызывается при любой попытке установить значение атрибута через нотацию с точкой или функцию `setattr()`.
**`__delattr__(self, name)`** — вызывается при попытке удалить атрибут с помощью `del`. 
**`__dir__(self)`** — позволяет настроить список атрибутов, который возвращает встроенная функция `dir()`.

Специальные атрибуты:

**`__class__`** — ссылка на класс экземпляра, то же самое, что и `type()`
**`__name__`** — имя класса (или функции)
**`__dict__`** — словарь, содержащий изменяемые атрибуты **объекта** или **класса** (не включает унаследованные атрибуты)
**`__bases__`** — кортеж суперклассов, из которых наследуется класс
**`__mro__`** — порядок разрешения методов (Method Resolution Order); кортеж классов, в которых Python ищет методы при обращении
**`__slots__`** — определяет фиксированный набор атрибутов экземпляра, отключает `__dict__` и экономит память


## Специальные методы

**Специальные методы** (*special methods*) — это методы с именами в формате `__имя__` (*double underscore* — *dunder*), которые вызываются интерпретатором при определенных операциях: создания объектов, преобразования в строку, итераций и др. Все специальные методы наследуются так же, как и обычные. По сути это механизм автоматической диспетчеризации (*automatic dispatch*) между выражениями и методами. Специальные методы предназначены для внутреннего использования интерпретатором, поэтому следует избегать явного обращения к ним.

Часть специальных методов отвечает за **перегрузку операций** (*operator overloading*) — они позволяют определить, как объект должен вести себя при использовании встроенных операторов и функций: сложения, вычитания, индексации и др.
операций.

Основные специальные методы:
**`__new__`** — создает и возвращает новый объект экземпляра, который затем передавается в `__init__` (если возвращается экземпляр другого класса, то конструктор не вызывается, а экземпляр возвращается сразу после создания)
**`__init__`** — конструктор, предназначен для инициализации состояния объекта(автоматически запускается только самый нижний конструктор в иерархии)  
**`__del__`** — деструктор, выполняется при уничтожении объекта  
**`__str__`** — выводит строковое представление объектов на экран, преобразуя их с помощью `str()`
**`__repr__`** — возвращает строковое представление объекта, максимально пригодное для отладки; по возможности — такое, которое можно использовать для воссоздания объекта через `eval()`; используется вместо `__str__`, если тот не определён
**`__format__`** — выполняется при вызове встроенной функции `format`
**`__call__`** — позволяет объекту вести себя как функция: если у объекта определён этот метод, то выполняется при вызове `obj(...)`
**`__getattr__`** — вызывается при обращении к неопределённому атрибуту; не вызывается, если атрибут найден в экземпляре, классе или суперклассах
**`__setattr__`** — перехватывает присваивания значений любым атрибутам; подвержен бесконечной рекурсии
**`__delattr__`** — вызывается при удалении атрибутов через `del`
**`__getattribute__`** — вызывается всегда при доступе к любому атрибуту; подвержен бесконечной рекурсии
**`__enter__`, `__exit__`** — методы контекстного менеджера  
**`__get__`, `__set__`, `__delete__`** — дескрипторы, перехватывают доступ к атрибутам
**`__iter__`, `__next__`** — протокол итерации: `__iter__` возвращает итерируемый объект, `__next__` выдаёт элементы до исключения `StopIteration`  
**`__getitem__`** — вызывается при операциях индексирования: `obj[key]`, `for`, `in`, срезы и др.; может использоваться как альтернатива итерации  
**`__setitem__`** — вызывается при присваивании значения по индексу или срезу  
**`__contains__`** — проверка членства `in`; если не определён, используется `__iter__` или `__getitem__`
**`__missing__`** — используется в наследниках `dict` при попытке доступа к отсутствующему ключу
**`__index__`** — возвращает целое число; используется в операциях, где от объекта ожидается целочисленный индекс
**`__bool__`** — определяет истинность экземпляра; если отсутствует, используется `__len__`
**`__len__`** — возвращает длину объекта


## Дескрипторы

**Дескриптор** — это объект, назначаемый атрибутом класса, который перехватывает операции чтения, записи и удаления этого атрибута с помощью методов `__get__`, `__set__` и `__delete__`. Дескрипторы используются для реализации `property`, `staticmethod`, `classmethod`, а также при использовании `__slots__`.

Всем методам дескриптора первым аргументом передаётся сам дескриптор (`self`), вторым — экземпляр класса, в котором используется дескриптор (`instance`). `__get__` дополнительно получает сам класс, к в котором определен дескриптор (`owner`), если доступ происходит через класс, а не через экземпляр.

**`__get__(self, instance, owner)`** — вызывается при чтении атрибута
**`__set__(self, instance, value)`** — вызывается при присваивании
**`__delete__(self, instance)`** — вызывается при удалении

Дескриптор является **атрибутом класса**, поэтому наследуется подклассами и экземплярами. Он перехватывает доступ к этому атрибуту у всех экземпляров. Существует два типа дескрипторов:

**Непереопределяющие дескрипторы** (*non-overriding descriptors*) — реализуют только `__get__`  и проигрывают в `MRO` обычным атрибутам потому что в этом случае `__dict__` имеет приоритет.
**Переопределяющие дескрипторы** (*overriding descriptors*) — реализуют `__get__` и хотя бы один из `__set__` или `__delete__` и имеют приоритет над `__dict__`.

Дескрипторы полезны для контроля доступа, валидации, кэширования, создания свойств и связывания методов.


## Свойства

**Свойства (property)** — это разновидность дескрипторов, позволяющая динамически вычислять значения атрибутов. По сути, это удобный способ создать дескриптор с помощью встроенной функции `property` (обычно используется как декоратор). Свойства реализуют атрибуты экземпляров, но не хранятся в `__dict__`, как и слоты. Свойство — это объект, присвоенный имени атрибута класса, и оно наследуется как классами, так и экземплярами. Функция `property` принимает до четырёх необязательных аргументов: функции чтения (`fget`), записи (`fset`), удаления (`fdel`) и строку документации (`doc`). Отсутствующий аргумент будет означать, что действие не поддерживается и при обращении будет вызван `AttributeError`. Объект свойства присваивается атрибуту класса:

```python
class A:
    def __init__(self):
        self._x = 0

    def get_x(self):
        return self._x

    def set_x(self, value):
        self._x = value

    x = property(get_x, set_x)
```


## Слоты

По умолчанию Python хранит атрибуты экземпляра в словаре `__dict__`, принадлежащем самому экземпляру. При большом числе объектов это может приводить к значительным затратам памяти, поскольку словари используют хеш-таблицы. Атрибут класса `__slots__` позволяет отказаться от словаря и хранить атрибуты в фиксированном кортеже, что значительно уменьшает занимаемую экземплярами память. Чтобы определить `__slots__`, достаточно присвоить ему итерируемый объект со строковыми именами допустимых атрибутов.

Атрибут `__slots__`, унаследованный от суперкласса, не оказывает влияния на подкласс — учитывается только тот `__slots__`, который задан в самом классе. Если нужно, чтобы подкласс тоже поддерживал слоты, в нём тоже нужно определить `__slots__`, но при этом слоты родительского класса унаследуются! При попытке создать подкласс от двух классов со слотами, генерируется ошибка `TypeError`.

Если включить `__dict__` в `__slots__`, то у экземпляра снова появится словарь атрибутов, и это позволит динамически добавлять любые новые атрибуты, не перечисленные в `__slots__`. Однако это лишает `__slots__` основного преимущества — экономии памяти, так как для хранения атрибутов вновь используется хеш-таблица.

Если необходимо, чтобы экземпляры поддерживали слабые ссылки, то в `__slots__` следует указать `__weakref__`.


## Интерфейсы и абстрактные классы `ABC`

Интерфейс — это подмножество открытых методов, которое позволяет объекту выполнять определённую роль (например, быть коллекцией). Интерфейсы формализуются через абстрактные базовые классы (*abstract base class*) `abc.ABC` или `collections.abc`. Класс, унаследованный от `abc.ABC`, становится абстрактным и не допускает создания экземпляров, пока не будут реализованы все помеченные методы `@abstractmethod`. Проверка осуществляется только при создании экземпляра. `ABC` могут включать и конкретные методы, но они должны использовать только другие методы из того же `ABC` или его суперклассов. Такие методы служат скорее удобством, чем необходимостью. Использование `ABC` позволяет явно задавать интерфейсы и при необходимости применять `isinstance(obj, ABC)` без нарушения утиной типизации — это допустимо, если `ABC` действительно является абстрактным базовым классом (его метакласс — `ABCMeta`). Они участвуют в механизме `MRO` и поддерживают регистрацию виртуальных подклассов без наследования. Явное использование ABC делает структуру кода более прозрачной, облегчает поддержку и совместимо с инструментами статического анализа.


## Виртуальные подклассы

Метод `__subclasses__()` возвращает только **реальные** (явно унаследованные) подклассы данного класса. Однако в случае абстрактных базовых классов возможен механизм **виртуального наследования**: с помощью метода `ABC.register(cls)` можно объявить класс виртуальным подклассом без фактического наследования. Такие классы будут успешно проходить проверки `issubclass()` и `isinstance()`, но не появятся в списке `__subclasses__()`. Виртуальные подклассы хранятся во внутреннем атрибуте `_abc_registry` абстрактного класса через `weakref`, чтобы не мешать сборке мусора. Это полезно, если нужно обозначить, что класс реализует интерфейс, не включая его в иерархию наследования.

Кроме того, класс может быть распознан как виртуальный подкласс **даже без регистрации**, если в `ABC` определён специальный метод `__subclasshook__`. Этот метод вызывается при проверке `issubclass(Cls, ABC)` и может вернуть `True`, `False` или `NotImplemented`(последний передаёт проверку стандартной логике). То есть `__subclasshook__` позволяет реализовать "утиную типизацию".


## Протоколы

**Протокол** в Python — это не формальный интерфейс, а неявный контракт: если объект реализует определённый набор методов или атрибутов, он считается соответствующим этому протоколу. Это основа утиной типизации (*duck typing*). Протоколы описывают ожидаемое поведение, а не конкретное происхождение объекта в иерархии классов.

Например, объект считается итерабельным, если реализует метод `__iter__()`, который возвращает итератор. А сам итератор должен реализовать метод `__next__()` и выбрасывать исключение `StopIteration` по завершении. Точно так же любой объект с методами `__getitem__` и `__len__` ведёт себя как последовательность. Для работы с контекстным менеджером достаточно реализовать методы `__enter__` и `__exit__`.

Начиная с `Python 3.8` появились явные протоколы `typing.Protocol`. Они позволяют аннотировать типы более строго и проверять соответствие через статический анализ:

```python
from typing import Protocol

class SupportsClose(Protocol):
    def close(self) -> None: ...

def finalize(obj: SupportsClose):
    obj.close()
```

Здесь любой объект, у которого есть метод `close()`, может быть передан в `finalize`, даже если он не наследуется от `SupportsClose`. Протоколы с `Protocol` также могут быть структурно проверены с помощью `isinstance()` или `issubclass()` при использовании `@runtime_checkable`.


## Метапрограммирование

Метапрограммирование в Python — это техника, позволяющая создавать и модифицировать классы во время выполнения. Поскольку классы сами являются объектами, их тоже можно создавать динамически. Для этого используется встроенный метакласс type, который обычно применяют как функцию, но на самом деле это класс, создающий другие классы. Вызов type с тремя аргументами создаёт новый класс:

```python
MyClass = type("MyClass", (MySuperClass, MyMixin), {"x": 42, "y": lambda self: self.x * 2})
```
Все классы по умолчанию являются экземплярами type, а `type`, в свою очередь, является экземпляром самого себя. Это означает, что классы создаются с помощью type или его подклассов, которые и называются метаклассами. Метаклассы позволяют управлять созданием и конфигурацией классов — например, абстрактные базовые классы `ABC` используют для этого собственный метакласс `ABCMeta`.

При создании нового класса метакласс может определить метод `__prepare__`, вызываемый до `__new__`. Он возвращает отображение (обычно dict), в которое будет помещён код тела класса. Затем `__new__` и `__init__` метакласса используют это отображение для построения итогового класса. Это позволяет, например, контролировать порядок определения атрибутов или внедрять дополнительную логику при создании класса.


