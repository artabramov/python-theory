# CPython

[1. Типизация](#1-типизация)

strongly typed
weakly typed
statically typed
dynamically typed
garbage collector
dynamic scope
lexical scope
equality
identity
shallow copy
deep copy
encoding
decoding
byte-order mark (BOM)
endianness
mutability
mutable
immutable
short-circuit evaluation
ASCII (American Standard Code for Information Interchange)

## 1. Типизация

Если в языке редко происходят неявные преобразования типов, он считается строго типизированным (*strongly typed*); если такие преобразования происходят часто — слабо типизированным (*weakly typed*). Если проверка типов выполняется на этапе компиляции и требует явного указания типов, язык называется статически типизированным (*statically typed*); если проверка происходит во время выполнения — динамически типизированным (*dynamically typed*).

Строгость типизации и момент её проверки — независимые характеристики. Язык может быть строго типизированным и при этом динамически типизированным (например, Python), либо строго и статически типизированным (например, Java). В противоположность этому, JavaScript — слабо и динамически типизированный язык.

Python — это высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью. Сборка мусора реализуется с помощью сборщика мусора (*garbage collector*), основанного на подсчёте ссылок и циклическом сборщике.

## 2. Мутабельность и хешируемость

Мутабельность (`mutability`) — это способность объекта изменяться после создания. В Python объекты бывают изменяемыми (`mutable`) и неизменяемыми (`immutable`). Мутабельность относится к объекту, а не к переменной. Переменные — это ссылки, и если две ссылки указывают на один изменяемый объект, изменения объекта будут затрагивать их обе.

Неизменяемые типы: `int`, `float`, `bool`, `str`, `tuple`, `frozenset`, а также все объекты, которые не предоставляют интерфейса для изменения своего состояния. Изменение таких объектов приводит не к их модификации, а к созданию новых объектов. Например, при конкатенации создаётся новая строка, а не изменяется исходная. Только неизменяемые объекты можно использовать как ключи в словарях и элементы множеств, так как их хэш остается постоянным.

Изменяемые типы: `list`, `dict`, `set`, `bytearray`, а также большинство пользовательских объектов. Они изменют своё состояние без изменения своей идентичности (`id`).

Хешируемость (*hashability*) — это свойство объекта, при котором он имеет стабильное значение, вычисляемое функцией `hash()`. То есть метод `__hash__` обязан возвращать одно и то же значение на протяжении всей жизни объекта независимо от его состояния. При этом должно поддерживаться сравнение на равенство (`==`), соблюдая при этом правило: если `a == b`, то обязательно `hash(a) == hash(b)`.

Хешируемыми являются все атомарные объекты: числа, строки, байты. Кортежи считаются хешируемыми только в том случае, если все их элементы тоже хешируемы. Пользовательские объекты по умолчанию хешируемы, так как их хэш равен `id`, но если определяется метод `__eq__`, необходимо также явно определить `__hash__`, чтобы сохранить логическое соответствие: если `a == b`, то `hash(a) == hash(b)`.

## 3. None

`None` — единственный экземпляр типа `NoneType`, обозначающий отсутствие значения. Он возвращается, если функция ничего не возвращает явно. Также используется для аргументов, чтобы отличить "не передано" от "передано явно", и может служить признаком того, что переменная ещё не определена. Кроме того, `None` нередко используется как заполнитель в структурах данных.

Сравнивать с `None` следует через `is`, а не `==`, так как `None` — синглтон, и важно проверять идентичность, а не равенство, которое может быть переопределено.

Тип `NoneType` не имеет доступных атрибутов и не может быть создан вручную (попытка вызвать `NoneType()` приведёт к ошибке).

## 5. Логические значения `bool`

Тип `bool` представляет логические значения и является подклассом `int`. Имеет два возможных значения: `True` (эквивалентен `1`) и `False` (эквивалентен `0`). Логические значения участвуют в арифметических операциях, могут использоваться как ключи в словарях и применяются во всех условных выражениях. Любой объект может быть приведён к `bool`, и его поведение в логических выражениях определяется методами `__bool__()` или `__len__()`, если они реализованы.

Функция `bool(x)` приводит объект x к логическому значению. Ложными считаются: `None`, `False`, `0`, `0.0`, `0j`, а также пустые строки, коллекции и диапазоны.

Операторы `not`, `and`, `or` работают по правилам логики, но возвращают не обязательно `True` или `False`, а сами значения операндов. Это связано с механизмом короткого замыкания (*short-circuit evaluation*): второй операнд не вычисляется, если результат уже ясен по первому. То есть `and` возвращает первое "ложное" значение или последнее, а `or` — первое "истинное":

```python
0 and "hello"      # вернёт 0
"hi" or "default"  # вернёт "hi"
```

Оператор `not` всегда возвращает логическое значение:

```python
not 0     # True
not "hi"  # False
```

## 6. Числа

**Натуральные числа** (ℕ, *natural numbers*) — это числа, используемые при счёте: 1, 2, 3, 4, … (в некоторых определениях — включая 0). Они замкнуты относительно сложения и умножения, но не вычитания.

**Целые числа** (ℤ, *integers*) включают ноль, положительные и отрицательные числа без дробной части: ..., −2, −1, 0, 1, 2, .... Они замкнуты относительно сложения, вычитания и умножения, но не деления: результат деления двух целых чисел не всегда целое число. В Python соответствуют типу `int`.

**Рациональные числа** (ℚ, *rational numbers*) — это числа, которые можно представить в виде дроби `m/n`, где `m` и `n` — целые числа, а `n ≠ 0`. Определены сложение, вычитание, умножение и деление (кроме деления на ноль). В Python соответствуют типу `fractions.Fraction`.

**Вещественные числа** (ℝ, *real numbers*) включают рациональные и иррациональные числа — те, которые не могут быть выражены в виде дроби (например, √2, π). Это непрерывное (*continuous*) множество, используемое для измерения величин. ℝ не счётно и не замкнуто в конечной точности — любое приближённое представление вещественного числа всегда ограничено. В Python соответствуют типу `float`.

**Комплексные числа** (ℂ, *complex numbers*) имеют вид `a + bi`, где `a` и `b` — вещественные числа, а `i` — мнимая единица (*imaginary unit*, `i² = −1`). Множество ℂ замкнуто относительно всех основных арифметических операций и содержит все корни многочленов с вещественными коэффициентами (в отличие от ℝ). В Python соответствуют типу `complex`.

Каждое последующее множество расширяет предыдущее, добавляя новые виды чисел и операции:

```
ℤ ⊂ ℚ ⊂ ℝ ⊂ ℂ
```

### 7. Целые числа `int`

Тип `int` представляет целые числа произвольной длины. В Python 3 их размер ограничен только доступной памятью. Это неизменяемый (`immutable`) тип. Объекты создаются напрямую (`x = 42`) или через `int(x)` с преобразованием. Если аргумент — строка, можно указать систему счисления: `int('101', 2)` => `5`.

Поддерживаются стандартные арифметические операции (`+`, `-`, `*`, `//`, `%`, `**`) и побитовые (`&`, `|`, `^`, `~`, `<<`, `>>`). Оператор `//` выполняет целочисленное деление с округлением вниз.

`abs(x)` — модуль числа,

`divmod(a, b)` — пара (`a // b`, `a % b`),

`pow(x, y, z)` — возведение в степень с остатком по модулю

`round(x)` — округление  

`bin(x)`, `oct(x)`, `hex(x)` — строковые представления в других системах счисления

## 8. Вещественные числа `float`

Тип `float` представляет вещественные (дробные) числа двойной точности, соответствующие формату IEEE 754. Они записываются с точкой (`3.14`, `-0.001`) или в экспоненциальной форме (`1e6`, `-2.5e-3`). Это неизменяемый (`immutable`) тип. Создаётся напрямую или через `float(x)`, где `x` — число, строка или объект с поддержкой преобразования.

Двойная точность (*double precision*) — это способ представления чисел с плавающей точкой, при котором на хранение значения отводится 64 бита (8 байт). Этот формат соответствует стандарту `IEEE 754` и обеспечивает примерно 15–17 значащих цифр десятичной точности. Ограниченная точность может вызывать ошибки округления при арифметике и сравнении. Например, `0.1 + 0.2` не равно `0.3` из-за особенностей двоичного представления дробей. Деление на ноль вызывает ошибку `ZeroDivisionError`, за исключением случаев с бесконечностью или отрицательным нулём.

Поддерживаются те же операции, что и для `int`, включая деление `/`, которое всегда возвращает `float`, даже если делится два целых числа. Операторы `//` и `%` при работе с `float` могут давать неожиданные результаты из-за особенностей округления.

`round(x, ndigits)` — округление

`math.isclose(a, b)` — сравнение с учётом погрешности

`math.isnan(x)`, `math.isinf(x)` — используются для проверки на специальные значения: не число (`nan`) и бесконечность (`inf`)

## 9. Специальные значения `inf` и `nan`

Тип `float` включает два специальных значения: бесконечность (`inf`, *infinity*) и не число (`nan`, *not a number*). То есть `inf` и `nan` входят в стандартный тип `float`.

`inf` и `-inf` представляют положительную и отрицательную бесконечность соответственно, создаются через `float('inf')` и `float('-inf')`. Значение `inf` можно сравнивать: `inf > 1e100` даст `True`.

`nan` обозначает неопределённый или некорректный результат вычислений. Его можно создать как `float('nan')`. Особенность `nan` в том, что оно не равно даже самому себе: `nan != nan`. Для проверки используется функция `math.isnan(x)`. `nan` часто используется для представления ошибок вычислений или отсутствующих данных.

## 10. Десятичные числа `decimal.Decimal`

Тип `decimal.Decimal` предоставляет точное представление десятичных дробей и используется, когда важна высокая точность вычислений (например, в финансовых расчётах). Он определяется в модуле `decimal`, который нужно явно импортировать. Объекты `Decimal` создаются из строк, чтобы избежать ошибок двоичного округления:

```python
Decimal("0.1") + Decimal("0.2") == Decimal("0.3")  # True
```

При создании из `float` теряется точность:

```python
Decimal(0.1)  # неточно
```

Преимуществами `Decimal` являются высокая точность без накопления ошибок округления, предсказуемое поведение при сравнении и сложении, а также возможность настройки арифметики через контекст. К недостаткам можно отнести меньшую производительность по сравнению с `float`.

Тип `Decimal` поддерживает все основные арифметические операции и работает вместе с `int`, но его не следует смешивать с `float`, чтобы избежать потери точности. Поведение вычислений зависит от текущего контекста (`decimal.getcontext()`), который определяет правила работы с числами типа `Decimal`. Он задаёт точность вычислений (количество значащих цифр), режим округления (вверх, вниз, к ближайшему), а также поведение при переполнении, делении на ноль, потере точности и других исключениях.

## 11. Комплексные числа

Комплексные числа представлены типом `complex`. Это встроенный тип, значения записываются в виде `a + bj`, где `a` — действительная часть, `b` — мнимая, а `j` — обозначение мнимой единицы (в отличие от математики, где обычно используют `i`). Мнимая часть может быть целым или дробным числом: `1j`, `2.5j`, `3 + 4j`.

Комплексные числа поддерживают арифметические операции: сложение, вычитание, умножение, деление, возведение в степень. Операторы `==` и `!=` допустимы, но операторы порядка (`<`, `>`, `>=`, `<=`) не поддерживаются и вызывают `TypeError`.

У комплексного числа доступны свойства `real` и `imag` для получения действительной и мнимой частей, функция `abs(z)` возвращает модуль (длину), а метод `conjugate()` — сопряжённое значение.

Модуль `cmath` предоставляет расширенные математические функции для работы с комплексными числами: тригонометрию, экспоненту, логарифмы и другие:

```python
import cmath
cmath.sqrt(-1)  # 1j
```

## 12. Строки

Строка (str) — неизменяемая последовательность символов Unicode, где каждый элемент — это символ, а не байт. Он имеет кодовую позицию — целое число, записываемое в шестнадцатеричном виде с префиксом `U+` (например, `U+00E9` для символа `é`).

Процесс преобразования в байты называется кодированием (*encoding*), а обратно — декодированием (*decoding*). Один и тот же символ может кодироваться по-разному в зависимости от кодировки. При кодировании и декодировании возможны ошибки:

`UnicodeEncodeError` — символ не может быть представлен в выбранной кодировке

`UnicodeDecodeError` — некорректная последовательность байтов при декодировании

Кодировка байтовой последовательности не всегда очевидна и должна задаваться явно. В случае неизвестной кодировки можно использовать эвристические инструменты, например, библиотеку `chardet`.

Строки поддерживают конкатенацию (`'a' + 'b'`), повторение (`'a' * 3`), индексацию и срезы (`s[1:4]`), поиск и замену (`s.find()`, `s.replace()`), разбиение и соединение (`s.split()`, `', '.join(list)`), изменение регистра (`s.upper()`, `s.lower()`), проверку начала и конца (`s.startswith()`, `s.endswith()`).

Форматирование строк:

f-строки (начиная с Python 3.6): `f"Hello, {name}!"`  

Метод `str.format()`: `"{} {}".format(a, b)`  

Старый стиль: `"%s %d" % (a, b)`

## 13. `BOM`

`BOM` (*byte-order mark*) — это специальная последовательность байтов, которая может находиться в начале текстового файла и служит для указания кодировки текста и порядка байтов (*endianness*). Сам `BOM` не является частью содержимого строки, но может повлиять на её обработку, особенно при чтении или сравнении:

```
| Кодировка   | BOM         |
|-------------|-------------|
| UTF-8       | EF BB BF    |
| UTF-16 (BE) | FE FF       |
| UTF-16 (LE) | FF FE       |
| UTF-32 (BE) | 00 00 FE FF |
| UTF-32 (LE) | FF FE 00 00 |
```

`BOM` в `UTF-8` не требуется и используется редко — в основном в системах `Windows`. В `UTF-16` и `UTF-32` он важен, так как без него невозможно определить порядок байтов: `big-endian` (старший байт записывается первым) или `little-endian` (младший байт записывается первым).

Наличие `BOM` в файле может вызвать проблемы: например, `open()` по умолчанию не удаляет `BOM` при чтении в `utf-8`, и он остаётся в начале строки. Для безопасного чтения таких файлов можно использовать кодировку `utf-8-sig`, которая автоматически удаляет `BOM`:

```python
with open("file.txt", encoding="utf-8-sig") as f:
    text = f.read()
```

## 14. Байтовые данные и бинарные структуры

Для работы с низкоуровневыми двоичными данными предусмотрены специальные типы `bytes` и `bytearray`. Это последовательности последовательности целых чисел от 0 до 255. Тип `bytes` неизменяем, `bytearray` — изменяем. Они используются, например, при кодировании строк (`s.encode('utf-8')`) и при чтении бинарных файлов. Эти типы поддерживают индексацию, срезы, сравнение, большинство строковых методов (кроме форматирования), а также специфические методы: `hex()`, `fromhex()` и др.

Модуль `struct` позволяет упаковывать и распаковывать бинарные данные в соответствии с заданным форматом. Это удобно для представления структур, аналогичных тем, что используются в языках низкого уровня, таких как `C`.

```python
import struct
data = struct.pack('<I2s', 1024, b'OK')  # Little-endian: int + 2 байта
num, msg = struct.unpack('<I2s', data)
```

Модуль `re` поддерживает работу с байтовыми строками, если шаблон также задан в байтовом виде. Это полезно при поиске бинарных паттернов (например, сигнатур в файлах).

Тип `memoryview` предоставляет доступ к данным `bytes`, `bytearray`, `array` и другим буферным объектам без копирования. Он позволяет эффективно обрабатывать большие массивы данных или потоковые фрагменты, изменяя их напрямую.

Эти инструменты особенно полезны при работе с сетевыми протоколами, бинарными форматами и низкоуровневым вводом-выводом.

## 15. Составные типы

**Составные типы** (*container types*) представляют собой структуры, содержащие несколько элементов. Они реализованы в виде последовательностей, множеств и отображений, но принцип один: такие объекты хранят не отдельное значение, а совокупность данных, к которым можно получить доступ по индексу, ключу или через перебор.

Последовательности делятся на два рода. В **контейнерных** (*container sequences*) — таких как `list`, `tuple` или `collections.deque` — хранятся ссылки на объекты любого типа. А в **плоских** (*flat sequences*), таких как `str`, `bytes`, `bytearray`, `memoryview` и `array.array`, — хранятся значения непосредственно, как атомарные данные.

Также различают **изменяемые** (*mutable sequences*) и **неизменяемые** (*immutable sequences*). К первым относятся `list`, `bytearray`, `array.array`, `collections.deque`, `memoryview`; ко вторым — `tuple`, `str` и `bytes`.

## 16. Списки `list`

**Список** — это упорядоченная, изменяемая последовательность объектов. Элементы могут быть любого типа, включая другие списки. Списки допускают повторения, позволяют обращаться к элементам по индексу и поддерживают срезы, перебор, сравнение и множество встроенных операций.

Создать список можно с помощью квадратных скобок: `a = [1, 2, 3]`, пустой список — `[]`. Также список можно создать через `list(iterable)`, преобразовав любой итерируемый объект.

Списки поддерживают индексацию (`a[0]`), срезы (`a[1:3]`), замену элементов (`a[0] = 42`), добавление (`a.append(x)`, `a.extend(seq)`, `a += seq`), вставку (`a.insert(i, x)`), удаление (`del a[i]`, `a.remove(x)`, `a.pop()`), разворот (`a.reverse()`), сортировку (`a.sort()`), копирование (`a.copy()`, `a[:]`) и подсчёт (`a.count(x)`, `a.index(x)`).

Важно, что присваивание `b = a` не создаёт копию списка, а лишь новую ссылку на тот же объект. Для независимой копии следует использовать `a.copy()` или `list(a)`.

Списки можно сравнивать лексикографически: сначала сравниваются первые элементы, затем вторые и так далее. Элементы при этом должны быть сравнимы между собой — иначе возникнет `TypeError`. Перебор выполняется стандартным образом: `for x in a`.

## 17. Кортежи `tuple`

**Кортеж** — это упорядоченная, **неизменяемая** последовательность объектов. Он похож на список, но не допускает изменение содержимого после создания.

Создать кортеж можно с помощью запятой: `t = 1, 2, 3`. Рекомендуется заключать его в скобки: `t = (1, 2, 3)`. Пустой кортеж записывается как `()`, а одноэлементный — с запятой: `(42,)`.

Кортежи поддерживают те же операции, что и списки: индексацию (`t[0]`), срезы (`t[1:]`), перебор (`for x in t`), объединение (`t1 + t2`), повторение (`t * 3`), а также сравнение. Однако большинство "изменяющих" методов в нём отсутствует.

Кортеж может содержать любые типы объектов, в том числе изменяемые. Однако, если сам кортеж используется как ключ в словаре или как элемент множества, все его элементы тоже должны быть хэшируемыми.

Часто кортежи используются для возвращения нескольких значений из функции или для упаковки-распаковки (`a, b = f()`).

Для более читаемых и самодокументирующихся структур существует тип `namedtuple` из модуля `collections`. Это расширение обычного кортежа, где каждому элементу присваивается имя. Такой объект ведёт себя как кортеж, но к значениям можно обращаться по именам:

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(3, 4)
print(p.x)  # 3
```

Объекты `collections.namedtuple` используют столько же памяти, сколько и обычные кортежи, поскольку имена полей хранятся в определении класса. Они также значительно компактнее, чем экземпляры обычных классов, потому что не содержат `__dict__` — все атрибуты фиксированы и не хранятся отдельно.

## 18. Множества `set`

**Множество** — это неупорядоченная коллекция уникальных объектов. Оно не сохраняет порядок элементов и не допускает повторений: если при создании указать одинаковые значения, они автоматически будут удалены. Множества полезны, когда нужно проверять наличие элемента, исключать дубликаты или выполнять классические операции теории множеств.

Создать множество можно с помощью фигурных скобок, указав значения через запятую, например `{1, 2, 3}`. При этом пустое множество создаётся через `set()`, так как `{}` по умолчанию интерпретируется как пустой словарь. Также можно преобразовать любой итерируемый объект в множество с помощью конструктора `set()`.

Множества изменяемы: можно добавлять элементы методом `add()`, удалять с помощью `remove()` или `discard()`. Первый вызывает ошибку, если элемента нет, второй — нет. Метод `pop()` удаляет и возвращает произвольный элемент. Полностью очистить множество позволяет метод `clear()`.

Поддерживаются основные операции множеств: объединение, пересечение, разность и симметрическая разность. Они доступны как в виде операторов (`|`, `&`, `-`, `^`), так и в виде методов. Также можно проверять отношения между множествами: одно может быть подмножеством или надмножеством другого.

Элементы множества должны быть хэшируемыми — например, числа, строки или кортежи. Попытка добавить в множество изменяемый объект вроде списка вызовет ошибку.

Если требуется неизменяемый вариант множества — например, для использования в качестве ключа в словаре — можно воспользоваться типом `frozenset`. Он ведёт себя как обычное множество, но не допускает модификации после создания.

## 19. Словари `dict`

**Словарь** — это ассоциативная структура, сопоставляющая ключи и значения. Доступ к элементам осуществляется не по индексу, а по ключу. Каждому ключу соответствует одно значение, а сами ключи в пределах одного словаря уникальны. Значения могут повторяться и быть любого типа.

В основе словаря лежит **хеш-таблица**, обеспечивающая очень быструю вставку, поиск и удаление элементов — независимо от его размера. Это достигается за счёт значительных затрат памяти и требования, чтобы все ключи были хешируемыми: неизменяемыми и поддерживающими методы __hash__ и __eq__. Если объект может изменяться, он не должен использоваться в качестве ключа, иначе возможны ошибки и некорректное поведение.

Словарь создаётся с помощью фигурных скобок: `{"a": 1, "b": 2}` или через конструктор `dict()`. Пустой словарь — это `{}`. Обращение к значению по ключу выполняется как `d["key"]`, а безопасный доступ — через `d.get("key")`, который возвращает `None` (или значение по умолчанию), если ключ не найден. Элемент можно добавить или обновить с помощью присваивания, удалить — с помощью `del`, `pop()` или `popitem()`. Методы `keys()`, `values()` и `items()` возвращают представления ключей, значений и пар. Словари поддерживают перебор, но порядок перебора не всегда совпадает с порядком вставки. Кроме того не следует изменять словарь во время итерации по нему.

Для формализации интерфейсов, совместимых с `dict`, модуль `collections.abc` предоставляет абстрактные базовые классы `Mapping` и `MutableMapping`. Проверить, соответствует ли объект поведению словаря, можно через `isinstance()`:

```python
from collections import abc
d = {}
isinstance(d, abc.Mapping)  # True
```

## 20. Распределение памяти

**Куча** (*heap*) — это область динамической памяти, где хранятся все объекты. Переменные содержат лишь ссылки, а сами объекты размещаются в куче. Память может выделяться и освобождаться в любом порядке.

За управление памятью отвечает собственный аллокатор **PyMalloc**, работающий поверх системного `malloc()` из `C`. `PyMalloc` — это аллокатор малых объектов (*small object allocator*), он используется для объектов размером **до 512 байт**.

Память в `PyMalloc` организована трёхуровнево: **арены** (*arena*) — крупные блоки по `256 КБ`, **пулы** (*pool*) — сегменты арены по `4 КБ` (предназначены для объектов одного размера) и **слоты** (*block*) — ячейки в пуле, в которые помещаются объекты (например, в один пул влезет 256 слотов по `16 байт` ).

При создании объекта **до 512 байт** `PyMalloc` ищет свободный слот нужного размера. Если подходящего пула нет — выделяется новый. Например, короткие строки часто хранятся в слотах по 56 байт.

Объекты **больше 512 байт** выделяются напрямую через **системный аллокатор** (*system malloc*) — это медленнее и менее эффективно. Такие объекты не делят память с другими: это снижает фрагментацию, но и ухудшает повторное использование. Освобождение происходит через `free()`, но оно лишь помечает память как доступную, не обязательно немедленно возвращая её ОС.

Оценить размер объекта в байтах можно с помощью `sys.getsizeof()`.

## 21. Сборка мусора

Python очищает память с помощью двух механизмов: немедленное освобождение при снижении **счётчика ссылок** (*reference counting*) на объект до нуля; и дополнительная сборка мусора через **циклический сборщик мусора** (*garbage collector*) `gc` при возникновении циклических ссылок.

Модуль `gc` работает по **поколенческой модели**: объекты делятся на поколения (`0` — новые объекты, `1` — выжившие после первой сборки, `2` — долго живущие объекты). Чем дольше объект живёт, тем реже проверяется. Доступно ручное управление:

`gc.collect()` — запускает сборку мусора вручную

`gc.get_count()` — возвращает количество объектов в каждом поколении

`gc.disable()` / `gc.enable()` — отключение и включение сборщика

`gc.set_debug()` — включает отладочную информацию.

Простые типы (`int`, `str`, `float`, `tuple`, `frozenset`) считаются неподверженными циклам и не участвуют в сборке мусора. Отслеживаются списки, словари, пользовательские объекты и замыкания.

Модуль `weakref`, позволяет создавать слабые ссылки — они не увеличивают счётчик ссылок (не создают циклические ссылки) и не препятствуют удалению объекта.

## 22. Представление типов в памяти

Все объекты в памяти представляют собой структуры, содержащие служебную информацию и собственные данные. Даже элементарные значения реализованы как полноценные объекты и занимают больше места, чем может показаться. Каждый объект содержит два обязательных поля:

**ob_refcnt** (*reference count*) — счётчик ссылок на объект

**tp_type** (*object type*) — указатель на структуру `PyTypeObject`

**padding** — добавочные байты для выравнивания структуры до размера, кратного 8 (на 64-битных системах); нужно для корректного размещения в памяти

Тип `None` представлен единственным объектом `NoneType`, реализованным как структура `PyNoneObject`. Это синглтон, который занимает около **16 байт**:

```
+-----------------------+
| PyNoneObject          |
+-----------------------+
| ob_refcnt        [8b] |
| tp_type          [8b] |
+-----------------------+
```

Тип `bool` реализован как структура `PyBoolObject`, которая наследуется от `PyLongObject`, но существует только в двух экземплярах: `True` и `False`. Каждый занимает около **24 байт**:

```
+-------------------------+
| PyBoolObject            |
+-------------------------+
| ob_refcnt          [8b] |
| tp_type            [8b] |
| padding            [4b] |
| ob_ival (0 или 1)  [4b] |
+-------------------------+
```

Тип `int` реализован как структура произвольной длины `PyLongObject`, что позволяет представлять числа неограниченного размера. В ней хранятся "цифры" в виде массива целых чисел `digit[]`, каждое из которых занимает **2 или 4 байта** (зависимост от конфигурации). Для малых чисел всё помещается в один слот, при увеличении числа добавляются дополнительные ячейки. Объект занимает от **28 байт**:

```
+------------------------------------+
| PyLongObject                       |
+------------------------------------+
| ob_refcnt                     [8b] |
| tp_type                       [8b] |
| padding                       [4b] |
| ob_size (число цифр и знак)   [4b] |
| digit[0] (массив цифр числа)  [4b] |
+------------------------------------+
```

Тип `float` реализован как структура фиксированного размера `PyFloatObject`. Он хранит число в формате `IEEE 754` (64-битное число с плавающей точкой) и занимает **24 байта**:

```
+-------------------------------------------+
| PyFloatObject                             |
+-------------------------------------------+
| ob_refcnt                            [8b] |
| tp_type                              [8b] |
| ob_fval (значение в формате double)  [8b] |
+-------------------------------------------+
```

Тип `str` реализован как структура переменной длины `PyUnicodeObject`. В упрощённой форме строка хранится как массив символов `data[]`. Минимальный размер пустой строки составляет **49 байт** (на 64-битной системе), а дальше — **1–4 байта** на символ, в зависимости от диапазона (`Latin1`, `UCS-2`, `UCS-4`). Для `ASCII` используется компактное представление без избыточных полей.

```
+----------------------------------------+
| PyUnicodeObject                        |
+----------------------------------------+
| ob_refcnt                         [8b] |
| tp_type                           [8b] |
| padding                           [1b] |
| state/flags/kind                  [4b] |
| length (количество символов)      [8b] |
| hash (кеш хеш-значения)           [8b] |
| data[] (массив символов Unicode)  [Nb] |
+----------------------------------------+
```

Тип `tuple` — это неизменяемый массив ссылок на объекты. Он реализован как структура `PyTupleObject` с фиксированным числом элементов. Пустой кортеж занимает около **40 байт**, каждый элемент добавляет **по 8 байт** (указатель):

```
+--------------------------------------------------+
| PyTupleObject                                    |
+--------------------------------------------------+
| ob_refcnt                                  [8]   |
| tp_type                                    [8]   |
| ob_size (количество элементов)             [8]   |
| ob_item[] (массив указателей на элементы)  [8*N] |
+--------------------------------------------------+
```

Тип `list` — это динамический массив ссылок на объекты. Объект `PyListObject` хранит длину и указатель на буфер `ob_item[]`, в котором лежат ссылки на элементы. Буфер может быть больше длины списка — это позволяет эффективно добавлять элементы без частого перераспределения. Пустой список занимает около **64 байт**, каждый элемент добавляет **8 байт**, но из-за буфера реальный размер больше.

```
+---------------------------------------------+
| PyListObject                                |
+---------------------------------------------+
| ob_refcnt                              [8b] |
| tp_type                                [8b] |
| allocated (размер выделенного буфера)  [8b] |
| ob_size (количество элементов)         [8b] |
| ob_item (указатель на ob_item[])       [8b] |
+---------------------------------------------+

+------------------------------+
| ob_item[]                    |
+------------------------------+
| ptr_0 (ссылка на obj0)  [8b] |
| ptr_1 (ссылка на obj1)  [8b] |
| ...                          |
+------------------------------+
```

Тип `set` реализован как объект `PySetObject`, управляющий внутренней хеш-таблицей. Он хранит только ключи и их хеши (без значений) и состоит из двух блоков: сам `PySetObject` и внешний массив `entries[]`, где размещаются пары `hash` + `key`. Таблица `entries[]` может перевыделяться при росте, но структура `PySetObject` остаётся фиксированной по размеру.

Память выделяется с запасом, чтобы избежать коллизий и сохранить быстрый доступ. При достижении порога загрузки таблица автоматически расширяется, и все элементы перехешируются. Пустое множество занимает около **216 байт**. Все ключи должны быть хешируемыми и неизменяемыми:

```
+-----------------------------------------------+
| PySetObject                                   |
+-----------------------------------------------+
| ob_refcnt                              [8b]   |
| tp_type                                [8b]   |
| used (число занятых ячеек)             [8b]   |
| fill (общее число ячеек)               [8b]   |
| mask (управляет размером таблицы)      [8b]   |
| hashseed (случайный сдвиг для защиты)  [8b]   |
| table (указатель на entries[])         [8b]   |
| smalltable (встроенный буфер)          [136b] |
+-----------------------------------------------+

+-------------------------------+
| entries[]                     | 
+------------------+------------+
| hash(key0)  [8b] | key0  [8b] |
| hash(key1)  [8b] | key1  [8b] |
| ...              |            |
+------------------+------------+
```

Тип `dict` реализован как объект `PyDictObject`, управляющий хеш-таблицей пар ключ–значение. Он состоит из двух частей: сам объект и таблица `ma_keys`, содержащая массив записей `entries[]`. Ключи и значения хранятся раздельно: ключи — в `entries[]`, значения — в `ma_values` (или вместе, если оптимизация не используется).

Хеш-таблица использует открытое хеширование с пробингом и хранит хеши ключей. При росте она расширяется с перераспределением элементов. Объект содержит указатель на таблицу, счётчики и параметры перераспределения. Пустой словарь занимает около **240 байт**. Ключи должны быть хешируемыми и неизменяемыми.

```
+-------------------------------------------------+
| PyDictObject                                    |
+-------------------------------------------------+
| ob_refcnt                                [8b]   |
| tp_type                                  [8b]   |
| padding и другие поля                    [200b] |
| ma_used (количество элементов)           [8b]   |
| ma_keys (указатель на PyDictKeysObject)  [8b]   |
| ma_values (указатель на ma_values[])     [8b]   |
+-------------------------------------------------+

+-------------------------------------------------+
| PyDictKeysObject                                |
+-------------------------------------------------+
| dk_size (размер таблицы)                [8 b]   |
| dk_nentries (число занятых ячеек)       [8 b]   |
| dk_indices[] (хеш-таблица)              [N]     |
| entries[] (массив структур: hash, key)  [16b*N] |
+-------------------------------------------------+

+------------------------------+
| ma_values[]                  |
|------------------------------|
| value0 (ссылка на obj0) [8b] |
| value1 (ссылка на obj1) [8b] |
| ...                          |
+------------------------------+

```

## 23. Функции

В Python функции — это объекты первого класса (экземпляры класса `function`). Их можно сохранять в переменные, передавать как аргументы, возвращать из других функций и создавать динамически. Функции определяются с помощью ключевого слова `def` или выражения `lambda` (создаются внутри выражений и могут содержать только выражения). Создание функции не вызывает её, интерпретатор просто создаёт объект `PyFunctionObject`, который содержит:

- **`__name__`** — имя функции
- **`__code__`** — ссылка на объект кода (метаданные и тело функции, скомпилированные в байт-код)
- **`__annotations__`** — аннотация аргументов и возвращаемого значения (игнорируются интерпретатором)
- **`__closure__`** — замыкания функции (привязки свободных аргументов)
- **`__globals__`** — глобальные переменные модуля, в котором определена функция
- **`__dict__`** — словарь атрибутов
- **`__call__`** — реализация протокола вызываемых объектов
- **`__defaults__`** — значения параметров по умолчанию
- **`__kwdefaults__`** — значения по умолчанию именованных параметров

Функции можно создавать во время выполнения — через `exec`, `eval` или вручную с помощью `types.FunctionType`.

**Функции высшего порядка** (*higher-order functions*) — это функции, которые принимают другие функции в качестве аргументов или возвращают их как результат: `map`, `filter`, `reduce`, `sorted`, `min`, `max`.

**Замыкания** (*closure*) — это функции, которые сохраняют ссылки на переменные из внешней области видимости (*enclosing scope*), даже после завершения этой области. Такие переменные называются **свободными** (*free variables*). В Python их имена хранятся в `__code__.co_freevars`, а значения — в `__closure__`, что позволяет функции обращаться к ним позже.

При определении функции её тело компилируется в объект кода (*code object*). Один объект кода может использоваться разными функциями — это позволяет реализовывать замыкания, декораторы и генерацию функций во время выполнения.

## 24. Области видимости

Область видимости определяет, где в программе доступны переменные или функции. Существуют два основных подхода: **лексическая** (статическая) и **динамическая** область видимости.


**Лексическая область видимости** (*lexical scope*) — используется в Python и большинстве современных языков. Область действия переменной определяется текстом программы: переменные видимы внутри той функции (или блока), в которой они определены, и недоступны снаружи. Вложенные функции сохраняют доступ к переменным внешней функции благодаря механизму замыканий.

**Динамическая область видимости** (*dynamic scope*) — используется в некоторых языках (например, старых версиях Lisp). В этом случае область действия переменной определяется цепочкой вызовов во время выполнения: функция может получить доступ к переменным своего вызывающего кода, если они ещё существуют в стеке вызовов.

Python использует лексическую область видимости и реализует её через правило **LEGB** (Local, Enclosing, Global, Built-in): при поиске имени интерпретатор проходит через четыре уровня — локальный, охватывающий (вложенные функции), глобальный и встроенный.

## 25. Объект кода

Объект кода (*code object*) — это структура, в которую компилируется тело функции. Он содержит всю информацию, необходимую для выполнения:

- **`co_code`** — байт-код: инструкции виртуальной машины Python (PVM).
- **`co_argcount`**, **`co_posonlyargcount`**, **`co_kwonlyargcount`** — количество позиционных и именованных аргументов.
- **`co_varnames`** — имена всех локальных переменных.
- **`co_consts`** — литералы, встречающиеся в теле функции.
- **`co_names`** — список имён, к которым происходит обращение (например, глобальные переменные).
- **`co_freevars`**, **`co_cellvars`** — переменные замыканий (если используются).
- **`co_name`**, **`co_firstlineno`** — имя функции и строка, с которой она начинается в исходнике.
- **`co_flags`** — битовая маска, отражающая особенности (использование `*args`, генераторов и т.п.).

Объекты кода неизменяемы и создаются автоматически при определении функции. Их можно исследовать для анализа или отладки.

Пример:

```python
def f(x): return x + 1

print(f.__code__.co_code)       # байт-код
print(f.__code__.co_varnames)   # ('x',)
print(f.__code__.co_consts)     # (None, 1)
```

## 26. Выполнение кода

Исполнение Python-кода проходит несколько этапов:

1. **Парсинг** (*parsing*) — исходный код преобразуется в дерево разбора (AST).
2. **Компиляция** (*compilation*) — AST компилируется в **байт-код** (объекты `code`), который сохраняется внутри объектов типа `code` и может быть записан в `.pyc`-файлы.
3. **Исполнение** (*execution*) — байт-код выполняется виртуальной машиной CPython, которая интерпретирует инструкции с помощью стека.

Основные инструменты:

- `eval()` — выполняет выражение;
- `exec()` — выполняет произвольный код.

При вызове функции создаётся **кадр стека** (*frame*), представленный объектом `PyFrameObject`. Он содержит:

- ссылку на `code`-объект,
- локальные и глобальные переменные,
- указатель на текущую инструкцию.

Каждый вызов функции добавляет новый фрейм в стек вызовов, а выход из функции удаляет его. Так формируется **цепочка вызовов**, которая управляется интерпретатором Python.

Дальше можно разобрать подробнее: `PyCodeObject`, `PyFrameObject`, структуру стека, области памяти, и сам интерпретационный цикл.

## Парсинг

На начальном этапе выполнения программы Python парсит исходный текст и разбирает его на **токены** (*lexical analysis* — лексический анализ), из которых затем строится **синтаксическое дерево** (*parse tree* — дерево разбора), отражающее полную структуру кода. Затем синтаксическое дерево преобразуется в более компактное — **абстрактное синтаксическое дерево** (*AST*, *abstract syntax tree*).

`AST` — это иерархическая структура, где каждый узел соответствует конструкции языка: присваиванию, вызову функции, арифметической операции и т.д. Например, выражение `x = a + 1` будет представлено как узел `Assign`, в котором есть `Name(id='x')` и `BinOp(left=Name(id='a'), op=Add(), right=Constant(1))`.

Для парсинга используется модуль `ast`, который позволяет: анализировать код как структуру дерева, модифицировать узлы дерева, создавать Python-код программно. Например:

```python
import ast

tree = ast.parse("x = a + 1")
print(ast.dump(tree, indent=2))
```

Результат:
```
Module(
  body=[
    Assign(
      targets=[Name(id='x', ctx=Store())],
      value=BinOp(
        left=Name(id='a', ctx=Load()),
        op=Add(),
        right=Constant(value=1)
      )
    )
  ],
  type_ignores=[]
)
```

## Компиляция

После построения абстрактного синтаксического дерева (`AST`) Python компилирует его в **байт-код** — промежуточное представление, понятное интерпретатору. Байт-код хранится в объекте типа `code` (`PyCodeObject`) и состоит из последовательности инструкций, аналогичных ассемблеру виртуальной машины Python.

Для преобразования AST в байт-код используется функция `compile()`:

```python
code = compile("x = a + 1", filename="<string>", mode="exec")
print(code.co_code)  # байт-код
```

Байт-код не зависит от платформы и версий ОС, но зависит от версии Python. Он не исполняется напрямую системой, а интерпретируется виртуальной машиной CPython.

Объект кода (code object) содержит:

- co_code: байт-код (строка байтов)
- co_consts: константы
- co_names: имена переменных
- co_varnames: имена локальных переменных
- co_freevars: свободные переменные (для замыканий)
- co_cellvars: переменные, используемые во вложенных функциях
- co_filename: имя файла
- co_name: имя функции
- co_firstlineno: номер первой строки
- другие поля

Скомпилированные объекты кода можно кэшировать в `.pyc`-файлах в каталоге `__pycache__`, чтобы ускорить повторный запуск программы.














